from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core
import xsigmamodules.Market

class stub_placement_type(int):
    AUTO:'stub_placement_type'
    BACK:'stub_placement_type'
    FRONT:'stub_placement_type'

class stub_type(int):
    LONGEND:'stub_type'
    LONGSTART:'stub_type'
    SHORTEND:'stub_type'
    SHORTSTART:'stub_type'

class Stub(object):
    @overload
    def __init__(self, stub_type:'stubType') -> None: ...
    @overload
    def __init__(self, __a:'Stub') -> None: ...
    def payment(self, prevCouponDate:'datetime', nextCouponDate:'datetime', stubStart:'datetime', stubEnd:'datetime', dcc:'dayCountConvention'): ...
    def to_string(self) -> str: ...

class bermudanStrikesLifeCycle(xsigmamodules.Market.lifeCycleData):
    @overload
    def excution_boundary_strikes(self, index:int) -> float: ...
    @overload
    def excution_boundary_strikes(self) -> Tuple[float, float]: ...

class instrument(object):
    def make_life_cycle_data(self) -> 'lifeCycleData': ...
    def size(self) -> int: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentBermudanSwaption(instrument):
    def make_life_cycle_data(self) -> 'lifeCycleData': ...
    def size(self) -> int: ...
    def swaptoins(self) -> Tuple['instrumentIrSwaption', 'instrumentIrSwaption']: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentCreditBond(instrument):
    def convention(self) -> 'dayCountConvention': ...
    def maturity(self) -> 'datetime': ...
    def size(self) -> int: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentIrBond(instrument):
    def convention(self) -> 'dayCountConvention': ...
    def maturity(self) -> 'datetime': ...
    def size(self) -> int: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentIrSpreadOption(instrument):
    def is_call(self) -> bool: ...
    def size(self) -> int: ...
    def spread(self) -> 'interestRateSpread': ...
    def strikes(self) -> Tuple[float, float]: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentIrSwaption(instrument):
    def is_call(self) -> bool: ...
    def size(self) -> int: ...
    def strikes(self) -> Tuple[float, float]: ...
    def swap(self) -> 'interestRateSwap': ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class interestRateSpread(object):
    def all_dates(self) -> Tuple['datetime', 'datetime']: ...
    def dfs(self) -> Tuple[float, float]: ...
    def expiry(self) -> 'datetime': ...
    def hessian(self, output:'matrix_IdE', value_aad:float, integral_decays:'matrix_IdE', dfs:Sequence[float]) -> None: ...
    def long_swap(self) -> 'interestRateSwap': ...
    def long_weight(self) -> float: ...
    def short_swap(self) -> 'interestRateSwap': ...
    def short_weight(self) -> float: ...
    def simulated_value(self, mm:'vector_IdE', curve:'discountCurve', strikes:Sequence[float], is_call:bool, moment_matching:bool) -> Tuple[float, float]: ...
    def value(self, strike:float, dfs:Sequence[float]) -> float: ...
    def value_aad(self, log_dfs_aad:MutableSequence[float], ret_aad:float, dfs:Sequence[float]) -> None: ...

class interestRateSwap(object):
    def all_dates(self) -> Tuple['datetime', 'datetime']: ...
    @overload
    def annuity(self, dfs:Sequence[float]) -> float: ...
    @overload
    def annuity(self) -> float: ...
    def annuity_aad(self, dfs_aad:MutableSequence[float], dfs:Sequence[float]) -> None: ...
    def expiry(self) -> 'datetime': ...
    def gradient(output:'vector_IdE', integral_decays:'matrix_IdE', log_dfs_aad:Sequence[float]) -> None: ...
    def hessian(self, output:'matrix_IdE', value_aad:float, G:'matrix_IdE', dfs:Sequence[float]) -> None: ...
    @overload
    def implied_volatility(self, value:float, strike:float, is_call:float=1) -> float: ...
    @overload
    def implied_volatility(self, volatility_surface:'irVolatilitySurface', strike:float) -> float: ...
    def is_caplet(self) -> bool: ...
    def maturity(self) -> 'datetime': ...
    def simulated_value(self, mm:'vector_IdE', curve:'discountCurve', strikes:Sequence[float], is_call:bool, moment_matching:bool, debug:bool) -> Tuple[float, float]: ...
    @overload
    def swap_rate(self, dfs:Sequence[float]) -> float: ...
    @overload
    def swap_rate(self) -> float: ...
    def swap_rate_aad(self, value_aad:float, dfs:Sequence[float], dfs_aad:MutableSequence[float]) -> None: ...
    def value(self, strike:float, dfs:Sequence[float]) -> float: ...

class marketConventionData(object): ...

class stubPlacement(object):
    def isEndStub(self, t:'tenor', startDate:'datetime', endDate:'datetime') -> bool: ...
    def isLongStub(self) -> bool: ...
    def isShortStub(self) -> bool: ...

