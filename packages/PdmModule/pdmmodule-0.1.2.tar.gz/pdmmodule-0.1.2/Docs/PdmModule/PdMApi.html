<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PdmModule.PdMApi API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PdmModule.PdMApi</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PdmModule.Handlers.pairdetectionHandler import PairDectionHandler
from PdmModule.utils.structure import Eventpoint,PredictionPoint


class PdmModule():
    &#39;&#39;&#39;
    This class is used to provide an api for streaming usage of Handlers methods.
    The method collect_data is called to pass data and get prediction
    and the method collect_event to pass an event to trigger reset of the technique (In current implementation any event passed triger reset.).


    detector_class: A tecnique handler wich follow the get_Datapoint, get_event interface from Handlers

    parameters : The parameters of the Handlers object to initialize
    &#39;&#39;&#39;
    def __init__(self,detector_class=PairDectionHandler,parameters={
        &#34;thresholdtype&#34; : &#34;selftunne&#34;,
        &#34;ProfileSize&#34; : 30,
        &#34;thresholdfactor&#34; : 15,
        &#34;ActualProfileSize&#34; : 0.25,
        &#34;sequencesize&#34; : 12,
        &#34;alarmsThreshold&#34; : 0,
        &#34;normz&#34; : False
    }):
        self.sources={}
        self.detector_class=detector_class
        self.parameters=parameters
        self.parameters[&#34;resetcodes&#34;]=[(&#39;reset&#39;,id)]

    def collect_data(self,timestamp,data,id):
        &#39;&#39;&#39;
            This method accepts a data point with timestamp from a source and returns a prediction. For not seen sources create a new instant of detector.

            timestamp: the timestamp of the data
            data: an numpy array contain features (real numbers)
            id: the source that these data related to
            &#39;&#39;&#39;
        if id in self.sources.keys():
            prediction=self.sources[id].get_Datapoint(timestamp,data, id)[0]
        else:
            self.sources[id]=self.detector_class(source=id,**self.parameters)
            prediction=self.sources[id].get_Datapoint(timestamp, data, id)[0]
        #prediction = PredictionPoint(anomaly_score, 0.5, alarm,self.thresholdtype,point.timestamp,point.source,notes=description,ensemble_details=(pairthresholds,pair_anomaly_scores))
        if prediction.score is None:
            notes=&#34;&#34;
            for qqq in range(len(data)):
                notes+=&#34;,0,0&#34;
            prediction = PredictionPoint(0, 0, False, &#34;&#34;, timestamp,
                                         id, notes=notes,
                                                 ensemble_details=&#34;&lt;&gt;&#34;)
        return prediction


    def collect_event(self,timestamp,desc,id):
        &#39;&#39;&#39;
               This method trigger rest on the specific source (id) passed

               timestamp: the timestamp of the event
               desc: description of the event
               id: the source in which reset is triggered.
               &#39;&#39;&#39;
        ev =Eventpoint(code=desc,source=id,timestamp=timestamp)
        if id in self.sources.keys():
            self.sources[id].get_event(ev)
        else:
            self.sources[id]=self.detector_class(source=id,**self.parameters)
            self.sources[id].get_event(ev)

class PdmModuleStatic():
    &#39;&#39;&#39;
        This class is used to provide an api for simulating streaming application of a technique.
        So given all data (raw and event timestamps that triger rest to the tecnique, its simulates the stream of data and returns predictions

        The method predict is called to pass data and events for specific source and get all predictions

        detector_class: A tecnique handler wich follow the get_Datapoint, get_event interface from Handlers

        parameters : The parameters of the Handlers object to initialize
        &#39;&#39;&#39;
    def __init__(self,detector_class=PairDectionHandler,parameters={
        &#34;thresholdtype&#34; : &#34;selftunne&#34;,
        &#34;ProfileSize&#34; : 30,
        &#34;thresholdfactor&#34; : 15,
        &#34;ActualProfileSize&#34; : 0.25,
        &#34;sequencesize&#34; : 12,
        &#34;alarmsThreshold&#34; : 0,
        &#34;normz&#34; : False
    }):
        self.detector_class = detector_class
        self.parameters = parameters
        self.parameters[&#34;resetcodes&#34;] = [(&#39;reset&#39;, id)]


    def predict(self,data,events,id):
        &#39;&#39;&#39;
               This method simulate the stream using the raw and event data

               data: a DataFrame of the feature data (each row is a data point) where the index contain timestamps
               events: a DataFrame with events data, it needs to have one column &#39;dt&#39; with timestamps of events and one &#39;desc&#39; with a relative description
               id: the source of simulated data.
           &#39;&#39;&#39;
        if &#39;dt&#39; not in events.columns:
            assert False, &#34; A column named dt is expected in event dataframe&#34;

        if &#39;desc&#39; not in events.columns:
            assert False, &#34; A column named dt is expected in event dataframe&#34;

        handler = self.detector_class(source=id, **self.parameters)
        predictions = []
        dtlist = events[&#39;dt&#39;].values
        di = 0
        ei = 0
        for i in range(len(data.index) + len(events.index)):
            if di &gt;= len(data.index):
                break
            elif ei &gt;= len(dtlist):
                prediction = handler.get_Datapoint(data.index[di], data.iloc[di].values, id)[0]
                if prediction.score is None:
                    notes = &#34;&#34;
                    for qqq in range(len(data)):
                        notes += &#34;,0,0&#34;
                    prediction = PredictionPoint(0, 0, False, &#34;&#34;, data.index[di], id, notes=notes,
                                                 ensemble_details=&#34;&lt;&gt;&#34;)
                predictions.append(prediction)
                di += 1
            elif data.index[di] &lt; dtlist[ei]:
                prediction = handler.get_Datapoint(data.index[di], data.iloc[di].values, id)[0]
                if prediction.score is None:
                    notes = &#34;&#34;
                    for qqq in range(len(data)):
                        notes += &#34;,0,0&#34;
                    prediction = PredictionPoint(0, 0, False, &#34;&#34;, data.index[di], id, notes=notes,
                                                 ensemble_details=&#34;&lt;&gt;&#34;)
                predictions.append(prediction)
                di += 1
            else:
                ev = Eventpoint(code=events.iloc[ei][&#34;desc&#34;], source=id, timestamp=dtlist[ei])
                handler.get_event(ev)
                ei += 1
        return predictions</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PdmModule.PdMApi.PdmModule"><code class="flex name class">
<span>class <span class="ident">PdmModule</span></span>
<span>(</span><span>detector_class=PdmModule.Handlers.pairdetectionHandler.PairDectionHandler, parameters={'thresholdtype': 'selftunne', 'ProfileSize': 30, 'thresholdfactor': 15, 'ActualProfileSize': 0.25, 'sequencesize': 12, 'alarmsThreshold': 0, 'normz': False})</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to provide an api for streaming usage of Handlers methods.
The method collect_data is called to pass data and get prediction
and the method collect_event to pass an event to trigger reset of the technique (In current implementation any event passed triger reset.).</p>
<p>detector_class: A tecnique handler wich follow the get_Datapoint, get_event interface from Handlers</p>
<p>parameters : The parameters of the Handlers object to initialize</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdmModule():
    &#39;&#39;&#39;
    This class is used to provide an api for streaming usage of Handlers methods.
    The method collect_data is called to pass data and get prediction
    and the method collect_event to pass an event to trigger reset of the technique (In current implementation any event passed triger reset.).


    detector_class: A tecnique handler wich follow the get_Datapoint, get_event interface from Handlers

    parameters : The parameters of the Handlers object to initialize
    &#39;&#39;&#39;
    def __init__(self,detector_class=PairDectionHandler,parameters={
        &#34;thresholdtype&#34; : &#34;selftunne&#34;,
        &#34;ProfileSize&#34; : 30,
        &#34;thresholdfactor&#34; : 15,
        &#34;ActualProfileSize&#34; : 0.25,
        &#34;sequencesize&#34; : 12,
        &#34;alarmsThreshold&#34; : 0,
        &#34;normz&#34; : False
    }):
        self.sources={}
        self.detector_class=detector_class
        self.parameters=parameters
        self.parameters[&#34;resetcodes&#34;]=[(&#39;reset&#39;,id)]

    def collect_data(self,timestamp,data,id):
        &#39;&#39;&#39;
            This method accepts a data point with timestamp from a source and returns a prediction. For not seen sources create a new instant of detector.

            timestamp: the timestamp of the data
            data: an numpy array contain features (real numbers)
            id: the source that these data related to
            &#39;&#39;&#39;
        if id in self.sources.keys():
            prediction=self.sources[id].get_Datapoint(timestamp,data, id)[0]
        else:
            self.sources[id]=self.detector_class(source=id,**self.parameters)
            prediction=self.sources[id].get_Datapoint(timestamp, data, id)[0]
        #prediction = PredictionPoint(anomaly_score, 0.5, alarm,self.thresholdtype,point.timestamp,point.source,notes=description,ensemble_details=(pairthresholds,pair_anomaly_scores))
        if prediction.score is None:
            notes=&#34;&#34;
            for qqq in range(len(data)):
                notes+=&#34;,0,0&#34;
            prediction = PredictionPoint(0, 0, False, &#34;&#34;, timestamp,
                                         id, notes=notes,
                                                 ensemble_details=&#34;&lt;&gt;&#34;)
        return prediction


    def collect_event(self,timestamp,desc,id):
        &#39;&#39;&#39;
               This method trigger rest on the specific source (id) passed

               timestamp: the timestamp of the event
               desc: description of the event
               id: the source in which reset is triggered.
               &#39;&#39;&#39;
        ev =Eventpoint(code=desc,source=id,timestamp=timestamp)
        if id in self.sources.keys():
            self.sources[id].get_event(ev)
        else:
            self.sources[id]=self.detector_class(source=id,**self.parameters)
            self.sources[id].get_event(ev)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PdmModule.PdMApi.PdmModule.collect_data"><code class="name flex">
<span>def <span class="ident">collect_data</span></span>(<span>self, timestamp, data, id)</span>
</code></dt>
<dd>
<div class="desc"><p>This method accepts a data point with timestamp from a source and returns a prediction. For not seen sources create a new instant of detector.</p>
<p>timestamp: the timestamp of the data
data: an numpy array contain features (real numbers)
id: the source that these data related to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_data(self,timestamp,data,id):
    &#39;&#39;&#39;
        This method accepts a data point with timestamp from a source and returns a prediction. For not seen sources create a new instant of detector.

        timestamp: the timestamp of the data
        data: an numpy array contain features (real numbers)
        id: the source that these data related to
        &#39;&#39;&#39;
    if id in self.sources.keys():
        prediction=self.sources[id].get_Datapoint(timestamp,data, id)[0]
    else:
        self.sources[id]=self.detector_class(source=id,**self.parameters)
        prediction=self.sources[id].get_Datapoint(timestamp, data, id)[0]
    #prediction = PredictionPoint(anomaly_score, 0.5, alarm,self.thresholdtype,point.timestamp,point.source,notes=description,ensemble_details=(pairthresholds,pair_anomaly_scores))
    if prediction.score is None:
        notes=&#34;&#34;
        for qqq in range(len(data)):
            notes+=&#34;,0,0&#34;
        prediction = PredictionPoint(0, 0, False, &#34;&#34;, timestamp,
                                     id, notes=notes,
                                             ensemble_details=&#34;&lt;&gt;&#34;)
    return prediction</code></pre>
</details>
</dd>
<dt id="PdmModule.PdMApi.PdmModule.collect_event"><code class="name flex">
<span>def <span class="ident">collect_event</span></span>(<span>self, timestamp, desc, id)</span>
</code></dt>
<dd>
<div class="desc"><p>This method trigger rest on the specific source (id) passed</p>
<p>timestamp: the timestamp of the event
desc: description of the event
id: the source in which reset is triggered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_event(self,timestamp,desc,id):
    &#39;&#39;&#39;
           This method trigger rest on the specific source (id) passed

           timestamp: the timestamp of the event
           desc: description of the event
           id: the source in which reset is triggered.
           &#39;&#39;&#39;
    ev =Eventpoint(code=desc,source=id,timestamp=timestamp)
    if id in self.sources.keys():
        self.sources[id].get_event(ev)
    else:
        self.sources[id]=self.detector_class(source=id,**self.parameters)
        self.sources[id].get_event(ev)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="PdmModule.PdMApi.PdmModuleStatic"><code class="flex name class">
<span>class <span class="ident">PdmModuleStatic</span></span>
<span>(</span><span>detector_class=PdmModule.Handlers.pairdetectionHandler.PairDectionHandler, parameters={'thresholdtype': 'selftunne', 'ProfileSize': 30, 'thresholdfactor': 15, 'ActualProfileSize': 0.25, 'sequencesize': 12, 'alarmsThreshold': 0, 'normz': False})</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to provide an api for simulating streaming application of a technique.
So given all data (raw and event timestamps that triger rest to the tecnique, its simulates the stream of data and returns predictions</p>
<p>The method predict is called to pass data and events for specific source and get all predictions</p>
<p>detector_class: A tecnique handler wich follow the get_Datapoint, get_event interface from Handlers</p>
<p>parameters : The parameters of the Handlers object to initialize</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdmModuleStatic():
    &#39;&#39;&#39;
        This class is used to provide an api for simulating streaming application of a technique.
        So given all data (raw and event timestamps that triger rest to the tecnique, its simulates the stream of data and returns predictions

        The method predict is called to pass data and events for specific source and get all predictions

        detector_class: A tecnique handler wich follow the get_Datapoint, get_event interface from Handlers

        parameters : The parameters of the Handlers object to initialize
        &#39;&#39;&#39;
    def __init__(self,detector_class=PairDectionHandler,parameters={
        &#34;thresholdtype&#34; : &#34;selftunne&#34;,
        &#34;ProfileSize&#34; : 30,
        &#34;thresholdfactor&#34; : 15,
        &#34;ActualProfileSize&#34; : 0.25,
        &#34;sequencesize&#34; : 12,
        &#34;alarmsThreshold&#34; : 0,
        &#34;normz&#34; : False
    }):
        self.detector_class = detector_class
        self.parameters = parameters
        self.parameters[&#34;resetcodes&#34;] = [(&#39;reset&#39;, id)]


    def predict(self,data,events,id):
        &#39;&#39;&#39;
               This method simulate the stream using the raw and event data

               data: a DataFrame of the feature data (each row is a data point) where the index contain timestamps
               events: a DataFrame with events data, it needs to have one column &#39;dt&#39; with timestamps of events and one &#39;desc&#39; with a relative description
               id: the source of simulated data.
           &#39;&#39;&#39;
        if &#39;dt&#39; not in events.columns:
            assert False, &#34; A column named dt is expected in event dataframe&#34;

        if &#39;desc&#39; not in events.columns:
            assert False, &#34; A column named dt is expected in event dataframe&#34;

        handler = self.detector_class(source=id, **self.parameters)
        predictions = []
        dtlist = events[&#39;dt&#39;].values
        di = 0
        ei = 0
        for i in range(len(data.index) + len(events.index)):
            if di &gt;= len(data.index):
                break
            elif ei &gt;= len(dtlist):
                prediction = handler.get_Datapoint(data.index[di], data.iloc[di].values, id)[0]
                if prediction.score is None:
                    notes = &#34;&#34;
                    for qqq in range(len(data)):
                        notes += &#34;,0,0&#34;
                    prediction = PredictionPoint(0, 0, False, &#34;&#34;, data.index[di], id, notes=notes,
                                                 ensemble_details=&#34;&lt;&gt;&#34;)
                predictions.append(prediction)
                di += 1
            elif data.index[di] &lt; dtlist[ei]:
                prediction = handler.get_Datapoint(data.index[di], data.iloc[di].values, id)[0]
                if prediction.score is None:
                    notes = &#34;&#34;
                    for qqq in range(len(data)):
                        notes += &#34;,0,0&#34;
                    prediction = PredictionPoint(0, 0, False, &#34;&#34;, data.index[di], id, notes=notes,
                                                 ensemble_details=&#34;&lt;&gt;&#34;)
                predictions.append(prediction)
                di += 1
            else:
                ev = Eventpoint(code=events.iloc[ei][&#34;desc&#34;], source=id, timestamp=dtlist[ei])
                handler.get_event(ev)
                ei += 1
        return predictions</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PdmModule.PdMApi.PdmModuleStatic.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, data, events, id)</span>
</code></dt>
<dd>
<div class="desc"><p>This method simulate the stream using the raw and event data</p>
<p>data: a DataFrame of the feature data (each row is a data point) where the index contain timestamps
events: a DataFrame with events data, it needs to have one column 'dt' with timestamps of events and one 'desc' with a relative description
id: the source of simulated data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self,data,events,id):
    &#39;&#39;&#39;
           This method simulate the stream using the raw and event data

           data: a DataFrame of the feature data (each row is a data point) where the index contain timestamps
           events: a DataFrame with events data, it needs to have one column &#39;dt&#39; with timestamps of events and one &#39;desc&#39; with a relative description
           id: the source of simulated data.
       &#39;&#39;&#39;
    if &#39;dt&#39; not in events.columns:
        assert False, &#34; A column named dt is expected in event dataframe&#34;

    if &#39;desc&#39; not in events.columns:
        assert False, &#34; A column named dt is expected in event dataframe&#34;

    handler = self.detector_class(source=id, **self.parameters)
    predictions = []
    dtlist = events[&#39;dt&#39;].values
    di = 0
    ei = 0
    for i in range(len(data.index) + len(events.index)):
        if di &gt;= len(data.index):
            break
        elif ei &gt;= len(dtlist):
            prediction = handler.get_Datapoint(data.index[di], data.iloc[di].values, id)[0]
            if prediction.score is None:
                notes = &#34;&#34;
                for qqq in range(len(data)):
                    notes += &#34;,0,0&#34;
                prediction = PredictionPoint(0, 0, False, &#34;&#34;, data.index[di], id, notes=notes,
                                             ensemble_details=&#34;&lt;&gt;&#34;)
            predictions.append(prediction)
            di += 1
        elif data.index[di] &lt; dtlist[ei]:
            prediction = handler.get_Datapoint(data.index[di], data.iloc[di].values, id)[0]
            if prediction.score is None:
                notes = &#34;&#34;
                for qqq in range(len(data)):
                    notes += &#34;,0,0&#34;
                prediction = PredictionPoint(0, 0, False, &#34;&#34;, data.index[di], id, notes=notes,
                                             ensemble_details=&#34;&lt;&gt;&#34;)
            predictions.append(prediction)
            di += 1
        else:
            ev = Eventpoint(code=events.iloc[ei][&#34;desc&#34;], source=id, timestamp=dtlist[ei])
            handler.get_event(ev)
            ei += 1
    return predictions</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PdmModule" href="index.html">PdmModule</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PdmModule.PdMApi.PdmModule" href="#PdmModule.PdMApi.PdmModule">PdmModule</a></code></h4>
<ul class="">
<li><code><a title="PdmModule.PdMApi.PdmModule.collect_data" href="#PdmModule.PdMApi.PdmModule.collect_data">collect_data</a></code></li>
<li><code><a title="PdmModule.PdMApi.PdmModule.collect_event" href="#PdmModule.PdMApi.PdmModule.collect_event">collect_event</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="PdmModule.PdMApi.PdmModuleStatic" href="#PdmModule.PdMApi.PdmModuleStatic">PdmModuleStatic</a></code></h4>
<ul class="">
<li><code><a title="PdmModule.PdMApi.PdmModuleStatic.predict" href="#PdmModule.PdMApi.PdmModuleStatic.predict">predict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>