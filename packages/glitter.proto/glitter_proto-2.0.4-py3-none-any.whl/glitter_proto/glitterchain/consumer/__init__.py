# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: glitterchain/consumer/consumer.proto, glitterchain/consumer/genesis.proto, glitterchain/consumer/params.proto, glitterchain/consumer/query.proto, glitterchain/consumer/tx.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...cosmos.base.query import v1beta1 as __cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class PledgeRequest(betterproto.Message):
    from_address: str = betterproto.string_field(1)
    dataset_name: str = betterproto.string_field(2)
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PledgeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ReleasePledgeRequest(betterproto.Message):
    from_address: str = betterproto.string_field(1)
    dataset_name: str = betterproto.string_field(2)
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ReleasePledgeResponse(betterproto.Message):
    completion_time: datetime = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Cpdt(betterproto.Message):
    """consumer pledge dataset token"""

    dataset_name: str = betterproto.string_field(1)
    amount: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class Consumer(betterproto.Message):
    consumer_address: str = betterproto.string_field(1)
    cpd_ts: List["Cpdt"] = betterproto.message_field(2)
    description: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ReleasingCpdt(betterproto.Message):
    consumer_address: str = betterproto.string_field(1)
    dataset_name: str = betterproto.string_field(2)
    entries: List["ReleasingCpdtEntry"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ReleasingCpdTs(betterproto.Message):
    r_cpd_ts: List["ReleasingCpdt"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ReleasingCpdtEntry(betterproto.Message):
    creation_height: int = betterproto.int64_field(1)
    completion_time: datetime = betterproto.message_field(2)
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ReleasingCpdtEvents(betterproto.Message):
    """*event*"""

    dataset_name: str = betterproto.string_field(1)
    consumer_address: str = betterproto.string_field(2)
    coins: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ReleasingDatasetExpiredEvents(betterproto.Message):
    dataset_name: str = betterproto.string_field(1)
    consumer_address: str = betterproto.string_field(2)
    coins: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    releasing_cpdt_wait_time: timedelta = betterproto.message_field(1)
    max_cpdt_entries: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryConsumerRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryConsumerResponse(betterproto.Message):
    consumer: "Consumer" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryConsumersRequest(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryConsumersResponse(betterproto.Message):
    consumer: List["Consumer"] = betterproto.message_field(1)
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryReleasingCpdtRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryReleasingCpdtResponse(betterproto.Message):
    releasing_cpd_ts: List["ReleasingCpdt"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryReleasingCpdTsRequest(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryReleasingCpdTsResponse(betterproto.Message):
    releasing_cpd_ts: List["ReleasingCpdt"] = betterproto.message_field(1)
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the index module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    consumers: List["Consumer"] = betterproto.message_field(2)
    releasing_cpd_ts: List["ReleasingCpdt"] = betterproto.message_field(3)


class MsgStub(betterproto.ServiceStub):
    async def pledge(
        self,
        pledge_request: "PledgeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PledgeResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Msg/Pledge",
            pledge_request,
            PledgeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def release_pledge(
        self,
        release_pledge_request: "ReleasePledgeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ReleasePledgeResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Msg/ReleasePledge",
            release_pledge_request,
            ReleasePledgeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_consumer(
        self,
        query_consumer_request: "QueryConsumerRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryConsumerResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Query/QueryConsumer",
            query_consumer_request,
            QueryConsumerResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_consumers(
        self,
        query_consumers_request: "QueryConsumersRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryConsumersResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Query/QueryConsumers",
            query_consumers_request,
            QueryConsumersResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_releasing_cpdt(
        self,
        query_releasing_cpdt_request: "QueryReleasingCpdtRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryReleasingCpdtResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Query/QueryReleasingCPDT",
            query_releasing_cpdt_request,
            QueryReleasingCpdtResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_releasing_cpd_ts(
        self,
        query_releasing_cpd_ts_request: "QueryReleasingCpdTsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryReleasingCpdTsResponse":
        return await self._unary_unary(
            "/glitterchain.consumer.Query/QueryReleasingCPDTs",
            query_releasing_cpd_ts_request,
            QueryReleasingCpdTsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def pledge(self, pledge_request: "PledgeRequest") -> "PledgeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def release_pledge(
        self, release_pledge_request: "ReleasePledgeRequest"
    ) -> "ReleasePledgeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_pledge(
        self, stream: "grpclib.server.Stream[PledgeRequest, PledgeResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.pledge(request)
        await stream.send_message(response)

    async def __rpc_release_pledge(
        self,
        stream: "grpclib.server.Stream[ReleasePledgeRequest, ReleasePledgeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.release_pledge(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/glitterchain.consumer.Msg/Pledge": grpclib.const.Handler(
                self.__rpc_pledge,
                grpclib.const.Cardinality.UNARY_UNARY,
                PledgeRequest,
                PledgeResponse,
            ),
            "/glitterchain.consumer.Msg/ReleasePledge": grpclib.const.Handler(
                self.__rpc_release_pledge,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReleasePledgeRequest,
                ReleasePledgeResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_consumer(
        self, query_consumer_request: "QueryConsumerRequest"
    ) -> "QueryConsumerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_consumers(
        self, query_consumers_request: "QueryConsumersRequest"
    ) -> "QueryConsumersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_releasing_cpdt(
        self, query_releasing_cpdt_request: "QueryReleasingCpdtRequest"
    ) -> "QueryReleasingCpdtResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_releasing_cpd_ts(
        self, query_releasing_cpd_ts_request: "QueryReleasingCpdTsRequest"
    ) -> "QueryReleasingCpdTsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    async def __rpc_query_consumer(
        self,
        stream: "grpclib.server.Stream[QueryConsumerRequest, QueryConsumerResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_consumer(request)
        await stream.send_message(response)

    async def __rpc_query_consumers(
        self,
        stream: "grpclib.server.Stream[QueryConsumersRequest, QueryConsumersResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_consumers(request)
        await stream.send_message(response)

    async def __rpc_query_releasing_cpdt(
        self,
        stream: "grpclib.server.Stream[QueryReleasingCpdtRequest, QueryReleasingCpdtResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_releasing_cpdt(request)
        await stream.send_message(response)

    async def __rpc_query_releasing_cpd_ts(
        self,
        stream: "grpclib.server.Stream[QueryReleasingCpdTsRequest, QueryReleasingCpdTsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_releasing_cpd_ts(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/glitterchain.consumer.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/glitterchain.consumer.Query/QueryConsumer": grpclib.const.Handler(
                self.__rpc_query_consumer,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryConsumerRequest,
                QueryConsumerResponse,
            ),
            "/glitterchain.consumer.Query/QueryConsumers": grpclib.const.Handler(
                self.__rpc_query_consumers,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryConsumersRequest,
                QueryConsumersResponse,
            ),
            "/glitterchain.consumer.Query/QueryReleasingCPDT": grpclib.const.Handler(
                self.__rpc_query_releasing_cpdt,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryReleasingCpdtRequest,
                QueryReleasingCpdtResponse,
            ),
            "/glitterchain.consumer.Query/QueryReleasingCPDTs": grpclib.const.Handler(
                self.__rpc_query_releasing_cpd_ts,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryReleasingCpdTsRequest,
                QueryReleasingCpdTsResponse,
            ),
        }
