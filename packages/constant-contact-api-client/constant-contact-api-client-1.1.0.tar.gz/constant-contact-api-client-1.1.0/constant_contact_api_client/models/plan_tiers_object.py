# coding: utf-8

"""
    Constant Contact API v3

    Swagger build version 3.0.2475

    The version of the OpenAPI document: 1.0.117
    Contact: webservices@constantcontact.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictInt, StrictStr
from pydantic import Field
from constant_contact_api_client.models.plan_tiers_object_current_tiers_inner import PlanTiersObjectCurrentTiersInner
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class PlanTiersObject(BaseModel):
    """
    Specifies client billing plan details including the type of plan, the plan tiers used, the current billing status, and the day of the month that the client is billed. When a client account is first provisioned, the `plan_type` defaults to a `Trial` account. After you change an account `billing_status` from `Trial` to any other `billing_status`, you cannot change it back to a `Trial` account.
    """ # noqa: E501
    plan_type: Optional[StrictStr] = Field(default=None, description="The billing plan that is associated with a client's Constant Contact account. The billing plan determines which Constant Contact product features that the client account can access. If you are not on the latest billing plan, contact the Constant Contact Partner Team. However, older billing plans and <code>plan_type</code> enum values will continue to be supported. <ul>   <li><code>TRIAL</code>: Provides limited product features for a non-billed account and the account has an expiration date.</li>   <li><code>BRONZE</code>: Billable plan that provides basic email and marketing tools.</li>     <li><code>SILVER</code>: Billable plan that provides all features available in the <code>BRONZE</code> plan, and adds some additional email campaign to features, such as contact segmentation and social media ads integration.</li>   <li><code>GOLD</code>: Billable plan that provides all available product features.</li> </ul>")
    current_tiers: Optional[List[PlanTiersObjectCurrentTiersInner]] = Field(default=None, description="Lists the billing plan tiers that are currently associated with a client account.")
    billing_status: Optional[StrictStr] = Field(default=None, description="The client's account billing status. When you first create a client account the <code>billing_status</code> defaults to <code>Trial</code>. Billing status values include:   <ul>     <li><code>Trial</code> - A non-paying trial client account (default value).</li>     <li><code>Open</code> - An active and paying client account.</li>     <li><code>Canceled</code> - A canceled client account.</li>     <li><code>Trial End</code> - The trial period has ended for this client account.</li>   </ul>")
    billing_day_of_month: Optional[StrictInt] = Field(default=None, description="This property is required when an account is not set up to use single billing. For trial accounts, the value is initially set to <code>null</code>. The value can only be changed when changing the <code>plan_type</code> from a trial account to a different type of plan, otherwise the value you enter is ignored. You can choose to enter a specific day of month or except the default value, which is the day that the <code>plan_type</code> value changes from a trial account plan to a different plan. Valid <code>billing_day_of_month</code> values include <code>1</code> through and including <code>31</code>.")
    __properties: ClassVar[List[str]] = ["plan_type", "current_tiers", "billing_status", "billing_day_of_month"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of PlanTiersObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in current_tiers (list)
        _items = []
        if self.current_tiers:
            for _item in self.current_tiers:
                if _item:
                    _items.append(_item.to_dict())
            _dict['current_tiers'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of PlanTiersObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "plan_type": obj.get("plan_type"),
            "current_tiers": [PlanTiersObjectCurrentTiersInner.from_dict(_item) for _item in obj.get("current_tiers")] if obj.get("current_tiers") is not None else None,
            "billing_status": obj.get("billing_status"),
            "billing_day_of_month": obj.get("billing_day_of_month")
        })
        return _obj


