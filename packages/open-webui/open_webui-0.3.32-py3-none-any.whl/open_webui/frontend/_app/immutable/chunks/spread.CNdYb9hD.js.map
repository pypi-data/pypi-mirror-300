{"version":3,"file":"spread.CNdYb9hD.js","sources":["../../../../../../node_modules/svelte/src/runtime/internal/each.js","../../../../../../node_modules/svelte/src/runtime/internal/spread.js"],"sourcesContent":["import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","/** @returns {{}} */\nexport function get_spread_update(levels, updates) {\n\tconst update = {};\n\tconst to_null_out = {};\n\tconst accounted_for = { $$scope: 1 };\n\tlet i = levels.length;\n\twhile (i--) {\n\t\tconst o = levels[i];\n\t\tconst n = updates[i];\n\t\tif (n) {\n\t\t\tfor (const key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\t\t\tfor (const key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (const key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\treturn update;\n}\n\nexport function get_spread_object(spread_props) {\n\treturn typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n"],"names":["ensure_array_like","array_like_or_iterator","outro_and_destroy_block","block","lookup","transition_out","update_keyed_each","old_blocks","dirty","get_key","dynamic","ctx","list","node","destroy","create_each_block","next","get_context","n","i","old_indexes","new_blocks","new_lookup","deltas","updates","child_ctx","key","will_move","did_move","insert","transition_in","new_block","old_block","new_key","old_key","run_all","get_spread_update","levels","update","to_null_out","accounted_for","o","get_spread_object","spread_props"],"mappings":"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","x_google_ignoreList":[0,1]}