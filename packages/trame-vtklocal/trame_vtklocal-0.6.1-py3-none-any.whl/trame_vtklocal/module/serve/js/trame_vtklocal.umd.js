(function(f,h){typeof exports=="object"&&typeof module<"u"?h(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],h):(f=typeof globalThis<"u"?globalThis:f||self,h(f.trame_vtklocal={},f.Vue))})(this,function(f,h){"use strict";const U="",b=[];function I(i){return new Promise(function(e,s){if(b.indexOf(i)===-1){b.push(i);var t=document.createElement("script");t.type="module",t.src=i,t.onload=e,t.onerror=s,document.body.appendChild(t)}else e(!1)})}class k{constructor(){this.updateInProgress=0,this.loaded=!1,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e){if(this.loaded)return;const s=`${e}/vtkWasmSceneManager.mjs`;await I(s);const t=await window.createVTKWasmSceneManager();t.initialize(),this.loaded=!0,this.sceneManager=t}bindNetwork(e,s,t){this.networkFetchState=e,this.networkFetchHash=s,this.networkFetchStatus=t}freeMemory(e=0){const s=this.sceneManager.getTotalBlobMemoryUsage(),t=Number(e);if(s>t){const n={};let c=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([o,d])=>{d<c&&(c=d);const m=d.toString();n[m]?n[m].push(o):n[m]=[o]});this.sceneManager.getTotalBlobMemoryUsage()>t;){const o=n[c];if(o)for(let d=0;d<o.length;d++)this.sceneManager.unRegisterBlob(o[d]),delete this.hashesMTime[o[d]];c++}}}async fetchState(e){const s=await this.networkFetchState(e);return this.pushState(s),s}pushState(e){var s;if(e.length>0){const t=JSON.parse(e),{Id:n,MTime:c}=t;this.stateMTimes[n]=c;let o=!0;this.renderWindowIds.has(n)&&((s=t==null?void 0:t.Interactor)!=null&&s.Id)&&(this.renderWindowIdToInteractorId.set(t.Interactor.Id,n),t.CanvasSelector=this.getCanvasSelector(n),this.sceneManager.registerState(JSON.stringify(t)),o=!1),this.renderWindowIdToInteractorId.has(n)&&(t.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(n)),this.sceneManager.registerState(JSON.stringify(t)),o=!1),o&&this.sceneManager.registerState(e)}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const s=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,s}pushHash(e,s){return this.pendingArrays[e]=new Promise(t=>{s.arrayBuffer?s.arrayBuffer().then(n=>{this.sceneManager.registerBlob(e,new Uint8Array(n)),this.hashesMTime[e]=this.currentMTime,t()}):(this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,t())}),this.pendingArrays[e]}async update(e){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const s=await this.networkFetchStatus(e),t=[];s.ids.forEach(([n,c])=>{(!this.stateMTimes[n]||this.stateMTimes[n]<c)&&t.push(this.fetchState(n))}),s.hashes.forEach(n=>{this.hashesMTime[n]||t.push(this.fetchHash(n)),this.hashesMTime[n]=this.currentMTime}),s.cameras.forEach(n=>Number(this.cameraIds.add(n))),s.ignore_ids.forEach(n=>this.sceneManager.unRegisterState(n)),await Promise.all(t),await Promise.all(Object.values(this.pendingArrays)),this.currentMTime++;try{this.sceneManager.updateObjectsFromStates()}catch(n){console.error("WASM update failed"),console.log(n)}}catch(s){console.error("Error in update",s)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update())}}getState(e,s=!1){const t=Number(e);return s&&this.stateCache[t]?this.stateCache[t]:(this.sceneManager.updateStateFromObject(t),this.sceneManager.getState(t))}clearStateCache(){this.stateCache={}}getStateValue(e,s=!1){const t=Array.isArray(e)?e:[e];let n=null;for(let c=0;c<t.length;c++){const o=t[c];c===0?n=this.getState(o,s):(n=n[o],n.Id&&(n=this.getState(n.Id,s)))}return n}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,s){const t=this.getCanvasSelector(e);let n=this.offlineCanvasContainer.querySelector(t);return n||(n=document.createElement("canvas"),n.setAttribute("class",t.substring(1)),n.setAttribute("tabindex","0")),s.appendChild(n),t}unbindCanvasToDOM(e){const s=this.getCanvasSelector(e),t=document.querySelector(s);t&&this.offlineCanvasContainer.appendChild(t)}}function S(i,e,s){return function(){e.clearStateCache();for(const[t,n]of Object.entries(s)){const c={};for(const[o,d]of Object.entries(n))c[o]=e.getStateValue(d,!0);i.state.set(t,c)}e.clearStateCache()}}const p={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera"],props:{renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},listeners:{type:Object}},setup(i,{emit:e}){const s=h.inject("trame"),t=s.state.get("__trame_vtklocal_wasm_url"),n=[],c=[],o=h.ref(null),d=i.wsClient||(s==null?void 0:s.client),m=h.toRef(i,"listeners"),a=new k;let M=null;async function W(r){return await d.getConnection().getSession().call("vtklocal.get.state",[r])}async function A(r){const u=await d.getConnection().getSession().call("vtklocal.get.hash",[r]);return u.arrayBuffer?new Uint8Array(await u.arrayBuffer()):u}async function E(r){return await d.getConnection().getSession().call("vtklocal.get.status",[r])}function j([r]){r.type==="state"&&a.pushState(r.content),r.type==="blob"&&a.pushHash(r.hash,r.content)}async function F(){const r=d.getConnection().getSession();M=r.subscribe("vtklocal.subscriptions",j),await r.call("vtklocal.subscribe.update",[i.renderWindow,1])}async function N(){const r=d.getConnection().getSession();M&&(r.unsubscribe(M),M=null),await r.call("vtklocal.subscribe.update",[i.renderWindow,-1])}function v(){const{width:r,height:l}=o.value.getBoundingClientRect(),u=Math.floor(r*window.devicePixelRatio+.5),g=Math.floor(l*window.devicePixelRatio+.5),y=h.unref(o).querySelector(a.getCanvasSelector(i.renderWindow));y&&a.loaded&&i.renderWindow&&(y.width=u,y.height=g,a.sceneManager.setSize(i.renderWindow,u,g),a.sceneManager.render(i.renderWindow))}let w=new ResizeObserver(v);function B(){a.freeMemory(i.cacheSize),e("memory-vtk",a.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",a.sceneManager.getTotalBlobMemoryUsage())}async function C(){a.loaded&&(await a.update(i.renderWindow),a.sceneManager.render(i.renderWindow),v(),e("updated"),B())}function P(r){a.sceneManager.resetCamera(r),a.sceneManager.render(i.renderWindow)}h.onMounted(async()=>{a.bindNetwork(W,A,E),await a.load(t);const r=a.bindCanvasToDOM(i.renderWindow,h.unref(o));h.unref(o).querySelector(r).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),i.eagerSync&&F(),await C(),a.cameraIds.forEach(l=>{n.push([l,a.sceneManager.addObserver(l,"ModifiedEvent",()=>{e("camera",a.getState(l))})])}),h.watchEffect(()=>{for(;c.length;){const[l,u]=c.pop();a.sceneManager.removeObserver(l,u)}for(const[l,u]of Object.entries(m.value||{})){const g=Number(l);for(const[y,x]of Object.entries(u||{})){const T=S(s,a,x);c.push([g,a.sceneManager.addObserver(g,y,T)]),T()}}}),a.sceneManager.startEventLoop(i.renderWindow),w&&w.observe(h.unref(o))}),h.onBeforeUnmount(()=>{for(M&&N();n.length;){const[r,l]=n.pop();a.sceneManager.removeObserver(r,l)}for(;c.length;){const[r,l]=c.pop();a.sceneManager.removeObserver(r,l)}a.sceneManager.stopEventLoop(i.renderWindow),w&&(w.disconnect(),w=null),a.unbindCanvasToDOM(i.renderWindow)});function R(r){S(s,a,r)()}return{container:o,update:C,resetCamera:P,evalStateExtract:R}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function O(i){Object.keys(p).forEach(e=>{i.component(e,p[e])})}f.install=O,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});
