# coding: utf-8

"""
    ChRIS Research Integration System: Ultron BackEnd (CUBE) API

    The ChRIS Ultron BackEnd (CUBE) is the core backend API of ChRIS. It manages ChRIS users, plugins, pipelines, and the provenance of data analyses as ChRIS feeds.

    The version of the OpenAPI document: ${GITHUB_REF_NAME:1}
    Contact: dev@babymri.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBytes, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PluginAdminRequest(BaseModel):
    """
    A Plugin serializer for the PluginAdminList JSON view.
    """ # noqa: E501
    version: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
    dock_image: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
    description: Optional[Annotated[str, Field(strict=True, max_length=2000)]] = None
    execshell: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
    selfpath: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
    selfexec: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
    min_number_of_workers: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
    max_number_of_workers: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
    min_cpu_limit: Optional[StrictInt] = None
    max_cpu_limit: Optional[StrictInt] = None
    min_memory_limit: Optional[StrictInt] = None
    max_memory_limit: Optional[StrictInt] = None
    min_gpu_limit: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
    max_gpu_limit: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
    fname: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None
    plugin_store_url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
    compute_names: Annotated[str, Field(min_length=1, strict=True, max_length=2000)]
    __properties: ClassVar[List[str]] = ["version", "dock_image", "description", "execshell", "selfpath", "selfexec", "min_number_of_workers", "max_number_of_workers", "min_cpu_limit", "max_cpu_limit", "min_memory_limit", "max_memory_limit", "min_gpu_limit", "max_gpu_limit", "fname", "plugin_store_url", "compute_names"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PluginAdminRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if min_number_of_workers (nullable) is None
        # and model_fields_set contains the field
        if self.min_number_of_workers is None and "min_number_of_workers" in self.model_fields_set:
            _dict['min_number_of_workers'] = None

        # set to None if max_number_of_workers (nullable) is None
        # and model_fields_set contains the field
        if self.max_number_of_workers is None and "max_number_of_workers" in self.model_fields_set:
            _dict['max_number_of_workers'] = None

        # set to None if min_cpu_limit (nullable) is None
        # and model_fields_set contains the field
        if self.min_cpu_limit is None and "min_cpu_limit" in self.model_fields_set:
            _dict['min_cpu_limit'] = None

        # set to None if max_cpu_limit (nullable) is None
        # and model_fields_set contains the field
        if self.max_cpu_limit is None and "max_cpu_limit" in self.model_fields_set:
            _dict['max_cpu_limit'] = None

        # set to None if min_memory_limit (nullable) is None
        # and model_fields_set contains the field
        if self.min_memory_limit is None and "min_memory_limit" in self.model_fields_set:
            _dict['min_memory_limit'] = None

        # set to None if max_memory_limit (nullable) is None
        # and model_fields_set contains the field
        if self.max_memory_limit is None and "max_memory_limit" in self.model_fields_set:
            _dict['max_memory_limit'] = None

        # set to None if min_gpu_limit (nullable) is None
        # and model_fields_set contains the field
        if self.min_gpu_limit is None and "min_gpu_limit" in self.model_fields_set:
            _dict['min_gpu_limit'] = None

        # set to None if max_gpu_limit (nullable) is None
        # and model_fields_set contains the field
        if self.max_gpu_limit is None and "max_gpu_limit" in self.model_fields_set:
            _dict['max_gpu_limit'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PluginAdminRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "version": obj.get("version"),
            "dock_image": obj.get("dock_image"),
            "description": obj.get("description"),
            "execshell": obj.get("execshell"),
            "selfpath": obj.get("selfpath"),
            "selfexec": obj.get("selfexec"),
            "min_number_of_workers": obj.get("min_number_of_workers"),
            "max_number_of_workers": obj.get("max_number_of_workers"),
            "min_cpu_limit": obj.get("min_cpu_limit"),
            "max_cpu_limit": obj.get("max_cpu_limit"),
            "min_memory_limit": obj.get("min_memory_limit"),
            "max_memory_limit": obj.get("max_memory_limit"),
            "min_gpu_limit": obj.get("min_gpu_limit"),
            "max_gpu_limit": obj.get("max_gpu_limit"),
            "fname": obj.get("fname"),
            "plugin_store_url": obj.get("plugin_store_url"),
            "compute_names": obj.get("compute_names")
        })
        return _obj


