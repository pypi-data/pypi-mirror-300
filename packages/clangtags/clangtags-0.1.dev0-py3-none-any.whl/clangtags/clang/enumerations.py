#===- enumerations.py - Python Enumerations ------------------*- python -*--===#
#
# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
#===------------------------------------------------------------------------===#
# shamelessly vendored on Oct 28, 2020 when I got mad at the weird api
# and it getting out of date on pypi.
#   - D.

"""
Clang Enumerations
==================

This module provides static definitions of enumerations that exist in
libclang.

Enumerations are typically defined as a list of tuples. The exported
values are typically munged into other types or classes at module load
time.

All enumerations are centrally defined in this file so they are all
grouped together and easier to audit. And, maybe even one day this file
will be automatically generated by scanning the libclang headers!
"""

# Maps to CXTokenKind. Note that libclang maintains a separate set of
# token enumerations from the C++ API.
TokenKinds = [
    ('PUNCTUATION', 0),
    ('KEYWORD', 1),
    ('IDENTIFIER', 2),
    ('LITERAL', 3),
    ('COMMENT', 4),
]

CURSOR_KINDS = [
###
# Declaration Kinds

# A declaration whose specific kind is not exposed via this interface.
#
# Unexposed declarations have the same operations as any other kind of
# declaration; one can extract their location information, spelling, find their
# definitions, etc. However, the specific kind of the declaration is not
# reported.
    ('UNEXPOSED_DECL', 1),

# A C or C++ struct.
    ('STRUCT_DECL', 2),

# A C or C++ union.
    ('UNION_DECL', 3),

# A C++ class.
    ('CLASS_DECL', 4),

# An enumeration.
    ('ENUM_DECL', 5),

# A field (in C) or non-static data member (in C++) in a struct, union, or C++
# class.
    ('FIELD_DECL', 6),

# An enumerator constant.
    ('ENUM_CONSTANT_DECL', 7),

# A function.
    ('FUNCTION_DECL', 8),

# A variable.
    ('VAR_DECL', 9),

# A function or method parameter.
    ('PARM_DECL', 10),

# An Objective-C @interface.
    ('OBJC_INTERFACE_DECL', 11),

# An Objective-C @interface for a category.
    ('OBJC_CATEGORY_DECL', 12),

# An Objective-C @protocol declaration.
    ('OBJC_PROTOCOL_DECL', 13),

# An Objective-C @property declaration.
    ('OBJC_PROPERTY_DECL', 14),

# An Objective-C instance variable.
    ('OBJC_IVAR_DECL', 15),

# An Objective-C instance method.
    ('OBJC_INSTANCE_METHOD_DECL', 16),

# An Objective-C class method.
    ('OBJC_CLASS_METHOD_DECL', 17),

# An Objective-C @implementation.
    ('OBJC_IMPLEMENTATION_DECL', 18),

# An Objective-C @implementation for a category.
    ('OBJC_CATEGORY_IMPL_DECL', 19),

# A typedef.
    ('TYPEDEF_DECL', 20),

# A C++ class method.
    ('CXX_METHOD', 21),

# A C++ namespace.
    ('NAMESPACE', 22),

# A linkage specification, e.g. 'extern "C"'.
    ('LINKAGE_SPEC', 23),

# A C++ constructor.
    ('CONSTRUCTOR', 24),

# A C++ destructor.
    ('DESTRUCTOR', 25),

# A C++ conversion function.
    ('CONVERSION_FUNCTION', 26),

# A C++ template type parameter
    ('TEMPLATE_TYPE_PARAMETER', 27),

# A C++ non-type template parameter.
    ('TEMPLATE_NON_TYPE_PARAMETER', 28),

# A C++ template template parameter.
    ('TEMPLATE_TEMPLATE_PARAMETER', 29),

# A C++ function template.
    ('FUNCTION_TEMPLATE', 30),

# A C++ class template.
    ('CLASS_TEMPLATE', 31),

# A C++ class template partial specialization.
    ('CLASS_TEMPLATE_PARTIAL_SPECIALIZATION', 32),

# A C++ namespace alias declaration.
    ('NAMESPACE_ALIAS', 33),

# A C++ using directive
    ('USING_DIRECTIVE', 34),

# A C++ using declaration
    ('USING_DECLARATION', 35),

# A Type alias decl.
    ('TYPE_ALIAS_DECL', 36),

# A Objective-C synthesize decl
    ('OBJC_SYNTHESIZE_DECL', 37),

# A Objective-C dynamic decl
    ('OBJC_DYNAMIC_DECL', 38),

# A C++ access specifier decl.
    ('CXX_ACCESS_SPEC_DECL', 39),


###
# Reference Kinds

    ('OBJC_SUPER_CLASS_REF', 40),
    ('OBJC_PROTOCOL_REF', 41),
    ('OBJC_CLASS_REF', 42),

# A reference to a type declaration.
#
# A type reference occurs anywhere where a type is named but not
# declared. For example, given:
#   typedef unsigned size_type;
#   size_type size;
#
# The typedef is a declaration of size_type (CXCursor_TypedefDecl),
# while the type of the variable "size" is referenced. The cursor
# referenced by the type of size is the typedef for size_type.
    ('TYPE_REF', 43),
    ('CXX_BASE_SPECIFIER', 44),

# A reference to a class template, function template, template
# template parameter, or class template partial specialization.
    ('TEMPLATE_REF', 45),

# A reference to a namespace or namepsace alias.
    ('NAMESPACE_REF', 46),

# A reference to a member of a struct, union, or class that occurs in
# some non-expression context, e.g., a designated initializer.
    ('MEMBER_REF', 47),

# A reference to a labeled statement.
    ('LABEL_REF', 48),

# A reference to a set of overloaded functions or function templates
# that has not yet been resolved to a specific function or function template.
    ('OVERLOADED_DECL_REF', 49),

# A reference to a variable that occurs in some non-expression
# context, e.g., a C++ lambda capture list.
    ('VARIABLE_REF', 50),

###
# Invalid/Error Kinds

    ('INVALID_FILE', 70),
    ('NO_DECL_FOUND', 71),
    ('NOT_IMPLEMENTED', 72),
    ('INVALID_CODE', 73),

###
# Expression Kinds

# An expression whose specific kind is not exposed via this interface.
#
# Unexposed expressions have the same operations as any other kind of
# expression; one can extract their location information, spelling, children,
# etc. However, the specific kind of the expression is not reported.
    ('UNEXPOSED_EXPR', 100),

# An expression that refers to some value declaration, such as a function,
# variable, or enumerator.
    ('DECL_REF_EXPR', 101),

# An expression that refers to a member of a struct, union, class, Objective-C
# class, etc.
    ('MEMBER_REF_EXPR', 102),

# An expression that calls a function.
    ('CALL_EXPR', 103),

# An expression that sends a message to an Objective-C object or class.
    ('OBJC_MESSAGE_EXPR', 104),

# An expression that represents a block literal.
    ('BLOCK_EXPR', 105),

# An integer literal.
    ('INTEGER_LITERAL', 106),

# A floating point number literal.
    ('FLOATING_LITERAL', 107),

# An imaginary number literal.
    ('IMAGINARY_LITERAL', 108),

# A string literal.
    ('STRING_LITERAL', 109),

# A character literal.
    ('CHARACTER_LITERAL', 110),

# A parenthesized expression, e.g. "(1)".
#
# This AST node is only formed if full location information is requested.
    ('PAREN_EXPR', 111),

# This represents the unary-expression's (except sizeof and
# alignof).
    ('UNARY_OPERATOR', 112),

# [C99 6.5.2.1] Array Subscripting.
    ('ARRAY_SUBSCRIPT_EXPR', 113),

# A builtin binary operation expression such as "x + y" or
# "x <= y".
    ('BINARY_OPERATOR', 114),

# Compound assignment such as "+=".
    ('COMPOUND_ASSIGNMENT_OPERATOR', 115),

# The ?: ternary operator.
    ('CONDITIONAL_OPERATOR', 116),

# An explicit cast in C (C99 6.5.4) or a C-style cast in C++
# (C++ [expr.cast]), which uses the syntax (Type)expr.
#
# For example: (int)f.
    ('CSTYLE_CAST_EXPR', 117),

# [C99 6.5.2.5]
    ('COMPOUND_LITERAL_EXPR', 118),

# Describes an C or C++ initializer list.
    ('INIT_LIST_EXPR', 119),

# The GNU address of label extension, representing &&label.
    ('ADDR_LABEL_EXPR', 120),

# This is the GNU Statement Expression extension: ({int X=4; X;})
    ('StmtExpr', 121),

# Represents a C11 generic selection.
    ('GENERIC_SELECTION_EXPR', 122),

# Implements the GNU __null extension, which is a name for a null
# pointer constant that has integral type (e.g., int or long) and is the same
# size and alignment as a pointer.
#
# The __null extension is typically only used by system headers, which define
# NULL as __null in C++ rather than using 0 (which is an integer that may not
# match the size of a pointer).
    ('GNU_NULL_EXPR', 123),

# C++'s static_cast<> expression.
    ('CXX_STATIC_CAST_EXPR', 124),

# C++'s dynamic_cast<> expression.
    ('CXX_DYNAMIC_CAST_EXPR', 125),

# C++'s reinterpret_cast<> expression.
    ('CXX_REINTERPRET_CAST_EXPR', 126),

# C++'s const_cast<> expression.
    ('CXX_CONST_CAST_EXPR', 127),

# Represents an explicit C++ type conversion that uses "functional"
# notion (C++ [expr.type.conv]).
#
# Example:
# \code
#   x = int(0.5);
# \endcode
    ('CXX_FUNCTIONAL_CAST_EXPR', 128),

# A C++ typeid expression (C++ [expr.typeid]).
    ('CXX_TYPEID_EXPR', 129),

# [C++ 2.13.5] C++ Boolean Literal.
    ('CXX_BOOL_LITERAL_EXPR', 130),

# [C++0x 2.14.7] C++ Pointer Literal.
    ('CXX_NULL_PTR_LITERAL_EXPR', 131),

# Represents the "this" expression in C++
    ('CXX_THIS_EXPR', 132),

# [C++ 15] C++ Throw Expression.
#
# This handles 'throw' and 'throw' assignment-expression. When
# assignment-expression isn't present, Op will be null.
    ('CXX_THROW_EXPR', 133),

# A new expression for memory allocation and constructor calls, e.g:
# "new CXXNewExpr(foo)".
    ('CXX_NEW_EXPR', 134),

# A delete expression for memory deallocation and destructor calls,
# e.g. "delete[] pArray".
    ('CXX_DELETE_EXPR', 135),

# Represents a unary expression.
    ('CXX_UNARY_EXPR', 136),

# ObjCStringLiteral, used for Objective-C string literals i.e. "foo".
    ('OBJC_STRING_LITERAL', 137),

# ObjCEncodeExpr, used for in Objective-C.
    ('OBJC_ENCODE_EXPR', 138),

# ObjCSelectorExpr used for in Objective-C.
    ('OBJC_SELECTOR_EXPR', 139),

# Objective-C's protocol expression.
    ('OBJC_PROTOCOL_EXPR', 140),

# An Objective-C "bridged" cast expression, which casts between
# Objective-C pointers and C pointers, transferring ownership in the process.
#
# \code
#   NSString *str = (__bridge_transfer NSString *)CFCreateString();
# \endcode
    ('OBJC_BRIDGE_CAST_EXPR', 141),

# Represents a C++0x pack expansion that produces a sequence of
# expressions.
#
# A pack expansion expression contains a pattern (which itself is an
# expression) followed by an ellipsis. For example:
    ('PACK_EXPANSION_EXPR', 142),

# Represents an expression that computes the length of a parameter
# pack.
    ('SIZE_OF_PACK_EXPR', 143),

# Represents a C++ lambda expression that produces a local function
# object.
#
#  \code
#  void abssort(float *x, unsigned N) {
#    std::sort(x, x + N,
#              [](float a, float b) {
#                return std::abs(a) < std::abs(b);
#              });
#  }
#  \endcode
    ('LAMBDA_EXPR', 144),

# Objective-c Boolean Literal.
    ('OBJ_BOOL_LITERAL_EXPR', 145),

# Represents the "self" expression in a ObjC method.
    ('OBJ_SELF_EXPR', 146),

# OpenMP 4.0 [2.4, Array Section].
    ('OMP_ARRAY_SECTION_EXPR', 147),

# Represents an @available(...) check.
    ('OBJC_AVAILABILITY_CHECK_EXPR', 148),


# For some reason, these are not in the package installed from
# the cheeseshop. So I had to define these myself.
# Source: https://clang.llvm.org/doxygen/group__CINDEX.html
#   - D., Oct 27, 2020
    ('OBJC_AVAILABILITY_CHECK_EXPR', 149),
    ('FIXED_POINT_LITERAL', 150),
    ('OMP_ARRAY_SHAPINGEXPR', 151),
    ('OMP_ITERATOR_EXPR', 152),

# A statement whose specific kind is not exposed via this interface.
#
# Unexposed statements have the same operations as any other kind of statement;
# one can extract their location information, spelling, children, etc. However,
# the specific kind of the statement is not reported.
    ('UNEXPOSED_STMT', 200),

# A labelled statement in a function.
    ('LABEL_STMT', 201),

# A compound statement
    ('COMPOUND_STMT', 202),

# A case statement.
    ('CASE_STMT', 203),

# A default statement.
    ('DEFAULT_STMT', 204),

# An if statement.
    ('IF_STMT', 205),

# A switch statement.
    ('SWITCH_STMT', 206),

# A while statement.
    ('WHILE_STMT', 207),

# A do statement.
    ('DO_STMT', 208),

# A for statement.
    ('FOR_STMT', 209),

# A goto statement.
    ('GOTO_STMT', 210),

# An indirect goto statement.
    ('INDIRECT_GOTO_STMT', 211),

# A continue statement.
    ('CONTINUE_STMT', 212),

# A break statement.
    ('BREAK_STMT', 213),

# A return statement.
    ('RETURN_STMT', 214),

# A GNU-style inline assembler statement.
    ('ASM_STMT', 215),

# Objective-C's overall @try-@catch-@finally statement.
    ('OBJC_AT_TRY_STMT', 216),

# Objective-C's @catch statement.
    ('OBJC_AT_CATCH_STMT', 217),

# Objective-C's @finally statement.
    ('OBJC_AT_FINALLY_STMT', 218),

# Objective-C's @throw statement.
    ('OBJC_AT_THROW_STMT', 219),

# Objective-C's @synchronized statement.
    ('OBJC_AT_SYNCHRONIZED_STMT', 220),

# Objective-C's autorealease pool statement.
    ('OBJC_AUTORELEASE_POOL_STMT', 221),

# Objective-C's for collection statement.
    ('OBJC_FOR_COLLECTION_STMT', 222),

# C++'s catch statement.
    ('CXX_CATCH_STMT', 223),

# C++'s try statement.
    ('CXX_TRY_STMT', 224),

# C++'s for (* : *) statement.
    ('CXX_FOR_RANGE_STMT', 225),

# Windows Structured Exception Handling's try statement.
    ('SEH_TRY_STMT', 226),

# Windows Structured Exception Handling's except statement.
    ('SEH_EXCEPT_STMT', 227),

# Windows Structured Exception Handling's finally statement.
    ('SEH_FINALLY_STMT', 228),

# A MS inline assembly statement extension.
    ('MS_ASM_STMT', 229),

# The null statement.
    ('NULL_STMT', 230),

# Adaptor class for mixing declarations with statements and expressions.
    ('DECL_STMT', 231),

# OpenMP parallel directive.
    ('OMP_PARALLEL_DIRECTIVE', 232),

# OpenMP SIMD directive.
    ('OMP_SIMD_DIRECTIVE', 233),

# OpenMP for directive.
    ('OMP_FOR_DIRECTIVE', 234),

# OpenMP sections directive.
    ('OMP_SECTIONS_DIRECTIVE', 235),

# OpenMP section directive.
    ('OMP_SECTION_DIRECTIVE', 236),

# OpenMP single directive.
    ('OMP_SINGLE_DIRECTIVE', 237),

# OpenMP parallel for directive.
    ('OMP_PARALLEL_FOR_DIRECTIVE', 238),

# OpenMP parallel sections directive.
    ('OMP_PARALLEL_SECTIONS_DIRECTIVE', 239),

# OpenMP task directive.
    ('OMP_TASK_DIRECTIVE', 240),

# OpenMP master directive.
    ('OMP_MASTER_DIRECTIVE', 241),

# OpenMP critical directive.
    ('OMP_CRITICAL_DIRECTIVE', 242),

# OpenMP taskyield directive.
    ('OMP_TASKYIELD_DIRECTIVE', 243),

# OpenMP barrier directive.
    ('OMP_BARRIER_DIRECTIVE', 244),

# OpenMP taskwait directive.
    ('OMP_TASKWAIT_DIRECTIVE', 245),

# OpenMP flush directive.
    ('OMP_FLUSH_DIRECTIVE', 246),

# Windows Structured Exception Handling's leave statement.
    ('SEH_LEAVE_STMT', 247),

# OpenMP ordered directive.
    ('OMP_ORDERED_DIRECTIVE', 248),

# OpenMP atomic directive.
    ('OMP_ATOMIC_DIRECTIVE', 249),

# OpenMP for SIMD directive.
    ('OMP_FOR_SIMD_DIRECTIVE', 250),

# OpenMP parallel for SIMD directive.
    ('OMP_PARALLELFORSIMD_DIRECTIVE', 251),

# OpenMP target directive.
    ('OMP_TARGET_DIRECTIVE', 252),

# OpenMP teams directive.
    ('OMP_TEAMS_DIRECTIVE', 253),

# OpenMP taskgroup directive.
    ('OMP_TASKGROUP_DIRECTIVE', 254),

# OpenMP cancellation point directive.
    ('OMP_CANCELLATION_POINT_DIRECTIVE', 255),

# OpenMP cancel directive.
    ('OMP_CANCEL_DIRECTIVE', 256),

# OpenMP target data directive.
    ('OMP_TARGET_DATA_DIRECTIVE', 257),

# OpenMP taskloop directive.
    ('OMP_TASK_LOOP_DIRECTIVE', 258),

# OpenMP taskloop simd directive.
    ('OMP_TASK_LOOP_SIMD_DIRECTIVE', 259),

# OpenMP distribute directive.
    ('OMP_DISTRIBUTE_DIRECTIVE', 260),

# OpenMP target enter data directive.
    ('OMP_TARGET_ENTER_DATA_DIRECTIVE', 261),

# OpenMP target exit data directive.
    ('OMP_TARGET_EXIT_DATA_DIRECTIVE', 262),

# OpenMP target parallel directive.
    ('OMP_TARGET_PARALLEL_DIRECTIVE', 263),

# OpenMP target parallel for directive.
    ('OMP_TARGET_PARALLELFOR_DIRECTIVE', 264),

# OpenMP target update directive.
    ('OMP_TARGET_UPDATE_DIRECTIVE', 265),

# OpenMP distribute parallel for directive.
    ('OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE', 266),

# OpenMP distribute parallel for simd directive.
    ('OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE', 267),

# OpenMP distribute simd directive.
    ('OMP_DISTRIBUTE_SIMD_DIRECTIVE', 268),

# OpenMP target parallel for simd directive.
    ('OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE', 269),

# OpenMP target simd directive.
    ('OMP_TARGET_SIMD_DIRECTIVE', 270),

# OpenMP teams distribute directive.
    ('OMP_TEAMS_DISTRIBUTE_DIRECTIVE', 271),

# For some reason, these are not in the package installed from
# the cheeseshop. So I had to define these myself.
# Source: https://clang.llvm.org/doxygen/group__CINDEX.html
#   - D., Oct 27, 2020
    ('OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE', 272),
    ('OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE', 273),
    ('OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE', 274),
    ('OMP_TARGET_TEAMS_DIRECTIVE', 275),
    ('OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE', 276),
    ('OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE', 277),
    ('OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMDDIRECTIVE', 278),
    ('OMP_TARGET_TEAMS_DISTRIBUTE_SIMDD_IRECTIVE', 279),
    ('BUILTIN_BITCAST_EXPR', 280),
    ('OMP_MASTER_TASK_LOOP_DIRECTIVE', 281),
    ('OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE', 282),
    ('OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE', 283),
    ('OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE', 284),
    ('OMP_PARALLEL_MASTER_DIRECTIVE', 285),
    ('OMP_DEPOBJ_DIRECTIVE', 286),
    ('OMP_SCAN_DIRECTIVE', 287),

###
# Other Kinds

# Cursor that represents the translation unit itself.
#
# The translation unit cursor exists primarily to act as the root cursor for
# traversing the contents of a translation unit.
    ('TRANSLATION_UNIT', 300),

###
# Attributes

# An attribute whoe specific kind is note exposed via this interface
    ('UNEXPOSED_ATTR', 400),

    ('IB_ACTION_ATTR', 401),
    ('IB_OUTLET_ATTR', 402),
    ('IB_OUTLET_COLLECTION_ATTR', 403),

    ('CXX_FINAL_ATTR', 404),
    ('CXX_OVERRIDE_ATTR', 405),
    ('ANNOTATE_ATTR', 406),
    ('ASM_LABEL_ATTR', 407),
    ('PACKED_ATTR', 408),
    ('PURE_ATTR', 409),
    ('CONST_ATTR', 410),
    ('NODUPLICATE_ATTR', 411),
    ('CUDACONSTANT_ATTR', 412),
    ('CUDADEVICE_ATTR', 413),
    ('CUDAGLOBAL_ATTR', 414),
    ('CUDAHOST_ATTR', 415),
    ('CUDASHARED_ATTR', 416),

    ('VISIBILITY_ATTR', 417),

    ('DLLEXPORT_ATTR', 418),
    ('DLLIMPORT_ATTR', 419),

# For some reason, these are not in the package installed from
# the cheeseshop. So I had to define these myself.
# Source: https://clang.llvm.org/doxygen/group__CINDEX.html
#   - D., Oct 27, 2020
    ('NS_RETURNS_RETAINED', 420),
    ('NS_RETURNS_NOT_RETAINED', 421),
    ('NS_RETURNS_AUTORELEASED', 422),
    ('NS_CONSUMES_SELF', 423),
    ('NS_CONSUMED', 424),
    ('OBJC_EXCEPTION', 425),
    ('OBJC_NSOBJECT', 426),
    ('OBJC_INDEPENDENT_CLASS', 427),
    ('OBJC_PRECISE_LIFETIME', 428),
    ('OBJC_RETURNS_INNER_POINTER', 429),
    ('OBJC_REQUIRES_SUPER', 430),
    ('OBJC_ROOT_CLASS', 431),
    ('OBJC_SUBCLASSING_RESTRICTED', 432),
    ('OBJC_EXPLICIT_PROTOCOL_IMPL', 433),
    ('OBJC_DESIGNATED_INITIALIZER', 434),
    ('OBJC_RUNTIME_VISIBLE', 435),
    ('OBJC_BOXABLE', 436),

    ('FLAG_ENUM', 437),
    ('CONVERGENT_ATTR', 438),
    ('WARN_UNUSED_ATTR', 439),
    ('WARN_UNUSED_RESULT_ATTR', 440),
    ('ALIGNED_ATTR', 441),

###
# Preprocessing
    ('PREPROCESSING_DIRECTIVE', 500),
    ('MACRO_DEFINITION', 501),
    ('MACRO_INSTANTIATION', 502),
    ('INCLUSION_DIRECTIVE', 503),

###
# Extra declaration

# A module import declaration.
    ('MODULE_IMPORT_DECL', 600),
# A type alias template declaration
    ('TYPE_ALIAS_TEMPLATE_DECL', 601),
# A static_assert or _Static_assert node
    ('STATIC_ASSERT', 602),
# A friend declaration
    ('FRIEND_DECL', 603),

# A code completion overload candidate.
    ('OVERLOAD_CANDIDATE', 700),
    ]
TEMPLATE_ARGUMENT_KINDS = [
    ('NULL', 0),
    ('TYPE', 1),
    ('DECLARATION', 2),
    ('NULLPTR', 3),
    ('INTEGRAL', 4),
    ]
EXCEPTION_SPECIFICATIONS = [
    ('NONE', 0),
    ('DYNAMIC_NONE', 1),
    ('DYNAMIC', 2),
    ('MS_ANY', 3),
    ('BASIC_NOEXCEPT', 4),
    ('COMPUTED_NOEXCEPT', 5),
    ('UNEVALUATED', 6),
    ('UNINSTANTIATED', 7),
    ('UNPARSED', 8),
    ]

STORAGE_CLASSES = [
    ('INVALID', 0),
    ('NONE', 1),
    ('EXTERN', 2),
    ('STATIC', 3),
    ('PRIVATEEXTERN', 4),
    ('OPENCLWORKGROUPLOCAL', 5),
    ('AUTO', 6),
    ('REGISTER', 7),
    ]

AVAILABILITY_KINDS = [
    ('AVAILABLE', 0),
    ('DEPRECATED', 1),
    ('NOT_AVAILABLE', 2),
    ('NOT_ACCESSIBLE', 3),
    ]
ACCESS_SPECIFIERS = [
    ('INVALID', 0),
    ('PUBLIC', 1),
    ('PROTECTED', 2),
    ('PRIVATE', 3),
    ('NONE', 4),
    ]

TYPE_KINDS = [
    ('INVALID', 0),
    ('UNEXPOSED', 1),
    ('VOID', 2),
    ('BOOL', 3),
    ('CHAR_U', 4),
    ('UCHAR', 5),
    ('CHAR16', 6),
    ('CHAR32', 7),
    ('USHORT', 8),
    ('UINT', 9),
    ('ULONG', 10),
    ('ULONGLONG', 11),
    ('UINT128', 12),
    ('CHAR_S', 13),
    ('SCHAR', 14),
    ('WCHAR', 15),
    ('SHORT', 16),
    ('INT', 17),
    ('LONG', 18),
    ('LONGLONG', 19),
    ('INT128', 20),
    ('FLOAT', 21),
    ('DOUBLE', 22),
    ('LONGDOUBLE', 23),
    ('NULLPTR', 24),
    ('OVERLOAD', 25),
    ('DEPENDENT', 26),
    ('OBJCID', 27),
    ('OBJCCLASS', 28),
    ('OBJCSEL', 29),
    ('FLOAT128', 30),
    ('HALF', 31),
    ('COMPLEX', 100),
    ('POINTER', 101),
    ('BLOCKPOINTER', 102),
    ('LVALUEREFERENCE', 103),
    ('RVALUEREFERENCE', 104),
    ('RECORD', 105),
    ('ENUM', 106),
    ('TYPEDEF', 107),
    ('OBJCINTERFACE', 108),
    ('OBJCOBJECTPOINTER', 109),
    ('FUNCTIONNOPROTO', 110),
    ('FUNCTIONPROTO', 111),
    ('CONSTANTARRAY', 112),
    ('VECTOR', 113),
    ('INCOMPLETEARRAY', 114),
    ('VARIABLEARRAY', 115),
    ('DEPENDENTSIZEDARRAY', 116),
    ('MEMBERPOINTER', 117),
    ('AUTO', 118),
    ('ELABORATED', 119),
    ('PIPE', 120),
    ('OCLIMAGE1DRO', 121),
    ('OCLIMAGE1DARRAYRO', 122),
    ('OCLIMAGE1DBUFFERRO', 123),
    ('OCLIMAGE2DRO', 124),
    ('OCLIMAGE2DARRAYRO', 125),
    ('OCLIMAGE2DDEPTHRO', 126),
    ('OCLIMAGE2DARRAYDEPTHRO', 127),
    ('OCLIMAGE2DMSAARO', 128),
    ('OCLIMAGE2DARRAYMSAARO', 129),
    ('OCLIMAGE2DMSAADEPTHRO', 130),
    ('OCLIMAGE2DARRAYMSAADEPTHRO', 131),
    ('OCLIMAGE3DRO', 132),
    ('OCLIMAGE1DWO', 133),
    ('OCLIMAGE1DARRAYWO', 134),
    ('OCLIMAGE1DBUFFERWO', 135),
    ('OCLIMAGE2DWO', 136),
    ('OCLIMAGE2DARRAYWO', 137),
    ('OCLIMAGE2DDEPTHWO', 138),
    ('OCLIMAGE2DARRAYDEPTHWO', 139),
    ('OCLIMAGE2DMSAAWO', 140),
    ('OCLIMAGE2DARRAYMSAAWO', 141),
    ('OCLIMAGE2DMSAADEPTHWO', 142),
    ('OCLIMAGE2DARRAYMSAADEPTHWO', 143),
    ('OCLIMAGE3DWO', 144),
    ('OCLIMAGE1DRW', 145),
    ('OCLIMAGE1DARRAYRW', 146),
    ('OCLIMAGE1DBUFFERRW', 147),
    ('OCLIMAGE2DRW', 148),
    ('OCLIMAGE2DARRAYRW', 149),
    ('OCLIMAGE2DDEPTHRW', 150),
    ('OCLIMAGE2DARRAYDEPTHRW', 151),
    ('OCLIMAGE2DMSAARW', 152),
    ('OCLIMAGE2DARRAYMSAARW', 153),
    ('OCLIMAGE2DMSAADEPTHRW', 154),
    ('OCLIMAGE2DARRAYMSAADEPTHRW', 155),
    ('OCLIMAGE3DRW', 156),
    ('OCLSAMPLER', 157),
    ('OCLEVENT', 158),
    ('OCLQUEUE', 159),
    ('OCLRESERVEID', 160),

    ('EXTVECTOR', 176),
    ('ATOMIC', 177),
    ]

LINKAGE_KINDS = [
    ('INVALID', 0),
    ('NO_LINKAGE', 1),
    ('INTERNAL', 2),
    ('UNIQUE_EXTERNAL', 3),
    ('EXTERNAL', 4),
    ]
REF_QUALIFIER_KINDS = [
    ('NONE', 0),
    ('LVALUE', 1),
    ('RVALUE', 2),
    ]
TLS_KINDS = [
    ('NONE', 0),
    ('DYNAMIC', 1),
    ('STATIC', 2),
    ]
__all__ = ['TokenKinds']
