from enum import member
import logging
from typing import Annotated

from langchain_core.tools import tool
from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
from langgraph.graph import StateGraph
from langgraph.graph.graph import CompiledGraph
from langgraph.graph.message import AnyMessage, add_messages
from langgraph.prebuilt import ToolNode
from pydantic import BaseModel

from mtmai.agents.ctx import get_mtmai_ctx
from mtmai.agents.graphs.abstract_graph import AbstractGraph
from mtmai.agents.nodes.article_editor_node import ArticleEditorNode
from mtmai.agents.nodes.on_chat_message_node import OnChatMessageNode
from mtmai.agents.nodes.on_chat_start_node import OnChatStartNode
from mtmai.agents.nodes.supervisor_node import SupervisorNode
from mtmai.llm.llm import get_fast_llm
from mtmai.models.chat import ThreadUIState
from pydantic import Field
from langgraph.graph import END, StateGraph, START

from mtmai.models.graph_config import HomeChatState

logger = logging.getLogger()

@tool(parse_docstring=False, response_format="content_and_artifact")
def coplilot_ui_tools(panel_name: str):
    """Call to control frontend coplilot ui panels"""
    return (
        "Operation successful",
        {
            "artifaceType": "AdminView",
            "props": {
                "title": "管理面板",
            },
        },
    )


def should_continue(state: HomeChatState):
    messages = state.messages

    if len(messages) > 0 and messages[-1].tool_calls:
        return "tools"
    return "human_chat"


class ChatGraph(AbstractGraph):
    def create_graph(self) -> StateGraph:
        tools = [coplilot_ui_tools]
        tool_node = ToolNode(tools)

        runnable = get_fast_llm()
        runnable = runnable.bind_tools(tools)

        wf = StateGraph(HomeChatState)
        wf.add_node("on_chat_start_node", OnChatStartNode(runnable))
        wf.add_node("supervisor", SupervisorNode(runnable))
        wf.add_node("human_chat", OnChatMessageNode(runnable))
        wf.add_node("article_editor", ArticleEditorNode(runnable))
        wf.add_node("tools", tool_node)

        wf.add_edge("on_chat_start_node", "supervisor")
        wf.add_conditional_edges(
            "human_chat",
            should_continue,
            {
                "tools": "tools",
                "continue": "supervisor",
            },
        )
        wf.add_edge("tools", "human_chat")
        wf.set_entry_point("on_chat_start_node")

        members = ["human_chat", "article_editor"]
        for member in members:
            wf.add_edge(member, "supervisor")
        conditional_map = {k: k for k in members}
        conditional_map["FINISH"] = END
        wf.add_conditional_edges("supervisor", lambda x: x.next, conditional_map)

        return wf

    async def get_compiled_graph(self) -> CompiledGraph:
        ctx = get_mtmai_ctx()
        checkpointer2 = AsyncPostgresSaver(await ctx.get_db_pool())
        wf = self.create_graph()
        return wf.compile(
            checkpointer=checkpointer2,
            # interrupt_after=["human_chat"],
            interrupt_before=["human_chat"],
            debug=True,
        )
