from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core
import xsigmamodules.Market

class parameter_markovian_hjm_type(int):
    HULL_WHITE:'parameter_markovian_hjm_type'
    PICEWISE_CONSTANT:'parameter_markovian_hjm_type'

class calibrationBlackKarasinskiSettings(xsigmamodules.Market.configData):
    def backward(self) -> bool: ...
    def debug(self) -> bool: ...
    def json_to_string(rhs:'calibrationBlackKarasinskiSettings') -> str: ...
    def level_lower_bound(self) -> float: ...
    def level_upper_bound(self) -> float: ...
    def mean_reversion_spead(self) -> float: ...
    def minimum_step(self) -> float: ...
    def pde_grid_size(self) -> int: ...
    def pde_span(self) -> float: ...
    def period(self) -> int: ...
    def read_from_binary(file_name:str) -> 'calibrationBlackKarasinskiSettings': ...
    def read_from_json(file_name:str) -> 'calibrationBlackKarasinskiSettings': ...
    def step(self) -> float: ...
    def tolerance(self) -> float: ...
    def update_bounds(self) -> bool: ...
    def use_adjustement(self) -> bool: ...
    def write_to_binary(file_name:str, rhs:'calibrationBlackKarasinskiSettings') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationBlackKarasinskiSettings') -> None: ...

class calibrationCheyetteSettings(xsigmamodules.Market.configData):
    def debug(self) -> bool: ...
    def json_to_string(rhs:'calibrationCheyetteSettings') -> str: ...
    def read_from_binary(file_name:str) -> 'calibrationCheyetteSettings': ...
    def read_from_json(file_name:str) -> 'calibrationCheyetteSettings': ...
    def tolerance(self) -> float: ...
    def type(self) -> 'parameterMarkovianHjmType': ...
    def write_to_binary(file_name:str, rhs:'calibrationCheyetteSettings') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationCheyetteSettings') -> None: ...

class calibrationCreditBlackKarasinski(object): ...

class calibrationHjmSettings(xsigmamodules.Market.configData):
    def debug(self) -> bool: ...
    def json_to_string(rhs:'calibrationHjmSettings') -> str: ...
    def read_from_binary(file_name:str) -> 'calibrationHjmSettings': ...
    def read_from_json(file_name:str) -> 'calibrationHjmSettings': ...
    def tolerance(self) -> float: ...
    def type(self) -> 'parameterMarkovianHjmType': ...
    def write_to_binary(file_name:str, rhs:'calibrationHjmSettings') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationHjmSettings') -> None: ...

class calibrationIrCheyette(object):
    def calibrate(self, volatility_surface:'irVolatilitySurface', settings:'calibrationCheyetteSettings', parameter_hjm:'parameterMarkovianHjm') -> 'parameterCheyette': ...
    def swaptions(self) -> Tuple['calibrationIrCheyetteSwaption', 'calibrationIrCheyetteSwaption']: ...

class calibrationIrHjm(object):
    def calibrate(self, volatility_surface:'irVolatilitySurface', correlation:'matrix_IdE', settings:'calibrationHjmSettings', strikes:Sequence[float]=..., initial_parameter:'parameterMarkovianHjm'=...) -> 'parameterMarkovianHjm': ...
    def cms_spread_pricing_experimental(valuation_date:'datetime', expiry_date:'datetime', parameter:'parameterMarkovianHjm', discount_crv:'discountCurve', use_forward_measure:bool=True) -> float: ...
    def swaptions(self) -> Tuple['calibrationIrHjmSwaption', 'calibrationIrHjmSwaption']: ...

class calibrationIrTargetsConfiguration(xsigmamodules.Market.configData):
    def cms_tenors(self) -> Tuple['tenor', 'tenor']: ...
    def coterminal(self) -> 'tenor': ...
    def expiries(self) -> Tuple['tenor', 'tenor']: ...
    def frequency(self) -> 'tenor': ...
    def include_caplets(self) -> bool: ...
    def include_cms(self) -> bool: ...
    def include_coterminal(self) -> bool: ...
    def json_to_string(rhs:'calibrationIrTargetsConfiguration') -> str: ...
    def read_from_binary(file_name:str) -> 'calibrationIrTargetsConfiguration': ...
    def read_from_json(file_name:str) -> 'calibrationIrTargetsConfiguration': ...
    def write_to_binary(file_name:str, rhs:'calibrationIrTargetsConfiguration') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationIrTargetsConfiguration') -> None: ...

class changeOfMeasure(object): ...

class correlationManager(xsigmamodules.Market.marketData):
    def id(self, i:int) -> 'diffusionId': ...
    def ids(self) -> Tuple['diffusionId', 'diffusionId']: ...
    def json_to_string(rhs:'correlationManager') -> str: ...
    def number_of_factors(self, id:'diffusionId') -> int: ...
    def pair_correlation_matrix(self, ids1:Sequence['diffusionId'], ids2:Sequence['diffusionId']) -> 'matrix_IdE': ...
    def read_from_binary(file_name:str) -> 'correlationManager': ...
    def read_from_json(file_name:str) -> 'correlationManager': ...
    def write_to_binary(file_name:str, rhs:'correlationManager') -> None: ...
    def write_to_json(file_name:str, rhs:'correlationManager') -> None: ...

class diffusion(object):
    def create_market_data(self, asset:'diffusion', next:'matrix_IdE', current:'matrix_IdE', data:Sequence['marketData']) -> 'marketData': ...
    def diffusion_discount_curve(data:'marketData') -> 'discountCurve': ...
    def diffusion_equity_spot(data:'marketData') -> 'equitySpot': ...
    def diffusion_fx_spot(data:'marketData') -> 'fxSpot': ...
    def diffusion_survival_curve(data:'marketData') -> 'survivalCurve': ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionCredit(diffusion):
    def create_market_data(self, asset:'diffusion', next:'matrix_IdE', current:'matrix_IdE', data:Sequence['marketData']) -> 'marketData': ...
    def log_conditional_survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...

class diffusionCreditBlackKarasinski(diffusionCredit):
    def log_conditional_survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...
    def survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...

class diffusionCreditExtendedCir(diffusionCredit):
    def log_conditional_survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...
    def survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...

class diffusionId(xsigmamodules.Market.marketDataId):
    def hash(self) -> int: ...
    def to_string(self) -> str: ...

class diffusionCreditId(diffusionId):
    def hash(self) -> int: ...
    def id(self) -> 'defaultId': ...
    def json_to_string(rhs:'diffusionCreditId') -> str: ...
    def read_from_binary(file_name:str) -> 'diffusionCreditId': ...
    def read_from_json(file_name:str) -> 'diffusionCreditId': ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:'diffusionCreditId') -> None: ...
    def write_to_json(file_name:str, rhs:'diffusionCreditId') -> None: ...

class diffusionCreditMarkovianHjm(diffusionCredit):
    def log_conditional_survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...
    def survival_probability(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...

class diffusionEquity(diffusion):
    def create_market_data(self, asset:'diffusion', next:'matrix_IdE', current:'matrix_IdE', data:Sequence['marketData']) -> 'marketData': ...
    def domestic_curve(self) -> 'discountCurve': ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionEquityId(diffusionId):
    def diffusion_ir_id_domestic(self) -> 'diffusionIrId': ...
    def hash(self) -> int: ...
    def json_to_string(rhs:'diffusionEquityId') -> str: ...
    def read_from_binary(file_name:str) -> 'diffusionEquityId': ...
    def read_from_json(file_name:str) -> 'diffusionEquityId': ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:'diffusionEquityId') -> None: ...
    def write_to_json(file_name:str, rhs:'diffusionEquityId') -> None: ...

class diffusionEquityLognormal(diffusionEquity):
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionFx(diffusion):
    def create_market_data(self, asset:'diffusion', next:'matrix_IdE', current:'matrix_IdE', data:Sequence['marketData']) -> 'marketData': ...
    def domestic_curve(self) -> 'discountCurve': ...
    def foreign_curve(self) -> 'discountCurve': ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionFxId(diffusionId):
    def diffusion_ir_id_domestic(self) -> 'diffusionIrId': ...
    def diffusion_ir_id_foreign(self) -> 'diffusionIrId': ...
    def hash(self) -> int: ...
    def json_to_string(rhs:'diffusionFxId') -> str: ...
    def read_from_binary(file_name:str) -> 'diffusionFxId': ...
    def read_from_json(file_name:str) -> 'diffusionFxId': ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:'diffusionFxId') -> None: ...
    def write_to_json(file_name:str, rhs:'diffusionFxId') -> None: ...

class diffusionFxLognormal(diffusionFx):
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionIr(diffusion):
    def create_market_data(self, asset:'diffusion', next:'matrix_IdE', current:'matrix_IdE', data:Sequence['marketData']) -> 'marketData': ...
    def discounting(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...
    def log_df(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def log_normalized_discounting(self, states:'matrix_IdE') -> 'vector_IdE': ...

class diffusionIrBlackKarasinski(diffusionIr):
    def discounting(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...
    def log_df(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionIrCheyette(diffusionIr):
    def discounting(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...
    def log_df(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionIrExtendedCir(diffusionIr):
    def discounting(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...
    def log_df(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class diffusionIrId(diffusionId):
    def hash(self) -> int: ...
    def id(self) -> 'discountId': ...
    def json_to_string(rhs:'diffusionIrId') -> str: ...
    def read_from_binary(file_name:str) -> 'diffusionIrId': ...
    def read_from_json(file_name:str) -> 'diffusionIrId': ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:'diffusionIrId') -> None: ...
    def write_to_json(file_name:str, rhs:'diffusionIrId') -> None: ...

class diffusionIrMarkovianHjm(diffusionIr):
    def discounting(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime') -> None: ...
    def log_df(self, output:'vector_IdE', states:'matrix_IdE', from_:'datetime', to:'datetime') -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initialize(self, states:'matrix_IdE') -> None: ...

class lognormalModelWithMhjmIr(object):
    def calibrate(self, calibration_dates:Sequence['datetime'], market_variance:Sequence[float], day_convention:'dayCountConvention') -> 'parameterLognormal': ...

class lognormalEquityWithMhjmIr(lognormalModelWithMhjmIr): ...

class lognormalFxWithMhjmIr(lognormalModelWithMhjmIr): ...

class measure(xsigmamodules.Market.configData):
    @overload
    def __init__(self, id:'discountId') -> None: ...
    @overload
    def __init__(self, __a:'measure') -> None: ...
    def id(self) -> 'discountId': ...
    def json_to_string(rhs:'measure') -> str: ...
    def read_from_binary(file_name:str) -> 'measure': ...
    def read_from_json(file_name:str) -> 'measure': ...
    def write_to_binary(file_name:str, rhs:'measure') -> None: ...
    def write_to_json(file_name:str, rhs:'measure') -> None: ...

class measureId(xsigmamodules.Market.configDataId):
    def hash(self) -> int: ...
    def json_to_string(rhs:'measureId') -> str: ...
    def read_from_binary(file_name:str) -> 'measureId': ...
    def read_from_json(file_name:str) -> 'measureId': ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:'measureId') -> None: ...
    def write_to_json(file_name:str, rhs:'measureId') -> None: ...

class parameterBlackKarasinski(xsigmamodules.Core.aadStateParametersManager):
    def json_to_string(rhs:'parameterBlackKarasinski') -> str: ...
    def levels_parameter_offset(self, t:'datetime') -> int: ...
    def parameters(self) -> 'parameterMarkovianHjm': ...
    def read_from_binary(file_name:str) -> 'parameterBlackKarasinski': ...
    def read_from_json(file_name:str) -> 'parameterBlackKarasinski': ...
    def write_to_binary(file_name:str, rhs:'parameterBlackKarasinski') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterBlackKarasinski') -> None: ...

class parameterCheyette(xsigmamodules.Core.aadStateParametersManager):
    def json_to_string(rhs:'parameterCheyette') -> str: ...
    def long_term_skew_level(self) -> float: ...
    def parameters(self) -> 'parameterMarkovianHjm': ...
    def read_from_binary(file_name:str) -> 'parameterCheyette': ...
    def read_from_json(file_name:str) -> 'parameterCheyette': ...
    def skew_parameter(self) -> 'matrix_IdE': ...
    def skew_parameter_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterCheyette') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterCheyette') -> None: ...

class parameterExtendedCir(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> 'matrix_IdE': ...
    def day_convention(self) -> 'dayCountConvention': ...
    def json_to_string(rhs:'parameterExtendedCir') -> str: ...
    def mean_reversion_speed_dates(self) -> Tuple['datetime', 'datetime']: ...
    def mean_reversion_speeds(self) -> 'matrix_IdE': ...
    def read_from_binary(file_name:str) -> 'parameterExtendedCir': ...
    def read_from_json(file_name:str) -> 'parameterExtendedCir': ...
    def shifts(self) -> 'matrix_IdE': ...
    def shifts_dates(self) -> Tuple['datetime', 'datetime']: ...
    def volatilities(self) -> 'matrix_IdE': ...
    def volatilities_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterExtendedCir') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterExtendedCir') -> None: ...

class parameterLognormal(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> 'matrix_IdE': ...
    def day_convention(self) -> 'dayCountConvention': ...
    def json_to_string(rhs:'parameterLognormal') -> str: ...
    def number_of_factors(self) -> int: ...
    def read_from_binary(file_name:str) -> 'parameterLognormal': ...
    def read_from_json(file_name:str) -> 'parameterLognormal': ...
    def volatilities(self) -> 'matrix_IdE': ...
    def volatilities_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterLognormal') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterLognormal') -> None: ...

class parameterMarkovianHjm(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> 'matrix_IdE': ...
    def day_convention(self) -> 'dayCountConvention': ...
    def decays(self) -> 'matrix_IdE': ...
    def decays_dates(self) -> Tuple['datetime', 'datetime']: ...
    def json_to_string(rhs:'parameterMarkovianHjm') -> str: ...
    def model_type(self) -> 'parameterMarkovianHjmType': ...
    def number_of_factors(self) -> int: ...
    def read_from_binary(file_name:str) -> 'parameterMarkovianHjm': ...
    def read_from_json(file_name:str) -> 'parameterMarkovianHjm': ...
    def volatilities(self) -> 'matrix_IdE': ...
    def volatilities_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterMarkovianHjm') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterMarkovianHjm') -> None: ...

class pdeManager(object):
    def dates(self) -> Tuple['datetime', 'datetime']: ...
    def dimensions(self) -> Tuple[int, int]: ...
    def pv(self, pvs:MutableSequence[float]) -> None: ...
    def run(self, pricers:Sequence['instrument'], adjustements:Sequence[float] =..., data:Sequence['lifeCycleData']=...) -> None: ...
    def size(self) -> int: ...

class randomConfig(xsigmamodules.Market.configData):
    def json_to_string(rhs:'randomConfig') -> str: ...
    def main_generator_type(self) -> 'randomType': ...
    def read_from_binary(file_name:str) -> 'randomConfig': ...
    def read_from_json(file_name:str) -> 'randomConfig': ...
    def settings(self) -> 'randomSettings': ...
    def write_to_binary(file_name:str, rhs:'randomConfig') -> None: ...
    def write_to_json(file_name:str, rhs:'randomConfig') -> None: ...

class randomManager(object):
    def correlate(self, time_index:int, decomposed_correlation:'matrix_IdE') -> 'matrix_IdE': ...
    def number_of_paths(self) -> int: ...

class simulationManager(object):
    def data(self, i:int) -> 'marketData': ...
    def propagate(self, time_index:int) -> None: ...
    def states_initialize(self) -> None: ...

