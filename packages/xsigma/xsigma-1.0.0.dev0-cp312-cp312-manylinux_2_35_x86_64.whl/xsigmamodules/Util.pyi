from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core
import xsigmamodules.xsigma

class ContractOutputFormat(int):
    C_MMM:'ContractOutputFormat'
    C_MMMYY:'ContractOutputFormat'
    C_M_:'ContractOutputFormat'
    C_M_YY:'ContractOutputFormat'
    DATE:'ContractOutputFormat'

class option_date(int): ...

class boundary_type(int):
    END:'boundary_type'
    NONE:'boundary_type'
    START:'boundary_type'

class business_day_convention_type(int):
    AUD_IMM:'business_day_convention_type'
    CAD_IMM:'business_day_convention_type'
    CDS_IMM:'business_day_convention_type'
    CDS_IMM_ADJ:'business_day_convention_type'
    FIRST_BDAY:'business_day_convention_type'
    FIRST_DAY:'business_day_convention_type'
    FOLLOWING:'business_day_convention_type'
    FX_FORWARD:'business_day_convention_type'
    IMM:'business_day_convention_type'
    INVALID:'business_day_convention_type'
    ISRAELI:'business_day_convention_type'
    KOREAN:'business_day_convention_type'
    LAST_BDAY:'business_day_convention_type'
    LAST_DAY:'business_day_convention_type'
    MODIFIED_FOLLOWING:'business_day_convention_type'
    MODIFIED_PRECEDING:'business_day_convention_type'
    NEXT_THURSDAY:'business_day_convention_type'
    NZD_IMM:'business_day_convention_type'
    PRECEDING:'business_day_convention_type'
    UNADJUSTED:'business_day_convention_type'

class day_count_convention_type(int):
    ACT_1230D:'day_count_convention_type'
    ACT_29:'day_count_convention_type'
    ACT_360:'day_count_convention_type'
    ACT_364:'day_count_convention_type'
    ACT_365:'day_count_convention_type'
    ACT_3656:'day_count_convention_type'
    ACT_365_25:'day_count_convention_type'
    ACT_365_A:'day_count_convention_type'
    ACT_ACT:'day_count_convention_type'
    BUS_252:'day_count_convention_type'
    B_1_1:'day_count_convention_type'
    B_1_2:'day_count_convention_type'
    B_1_4:'day_count_convention_type'
    B_30E_360:'day_count_convention_type'
    B_30G_360:'day_count_convention_type'
    B_30U_360:'day_count_convention_type'
    B_30_360:'day_count_convention_type'
    B_30_360_1:'day_count_convention_type'
    FIXED_360:'day_count_convention_type'
    INVALID:'day_count_convention_type'
    ISMA:'day_count_convention_type'
    NL_365:'day_count_convention_type'

class density_smoothing_type(int):
    LINEAR:'density_smoothing_type'
    LINEARC0:'density_smoothing_type'
    MIDPOINT:'density_smoothing_type'
    NONE:'density_smoothing_type'

class frequency_type(int):
    ANNUAL:'frequency_type'
    BIMONTHLY:'frequency_type'
    BIWEEKLY:'frequency_type'
    DAILY:'frequency_type'
    FOURMONTHLY:'frequency_type'
    FOURWEEKLY:'frequency_type'
    INVALID:'frequency_type'
    MONTHLY:'frequency_type'
    QUARTERLY:'frequency_type'
    SEMI_ANNUAL:'frequency_type'
    WEEKLY:'frequency_type'

class future_convention_type(int):
    B:'future_convention_type'
    BMF:'future_convention_type'
    BMF_DOL:'future_convention_type'
    BUND:'future_convention_type'
    BUND_OPT:'future_convention_type'
    BUND_OPT_1W:'future_convention_type'
    BUND_OPT_2W:'future_convention_type'
    BUND_OPT_3W:'future_convention_type'
    BUND_OPT_4W:'future_convention_type'
    BUND_OPT_5W:'future_convention_type'
    B_OPT:'future_convention_type'
    CGB:'future_convention_type'
    CGB_CFEX:'future_convention_type'
    DAP:'future_convention_type'
    DATEEXPR:'future_convention_type'
    EONIA:'future_convention_type'
    EOQ:'future_convention_type'
    EOY:'future_convention_type'
    ESTR3M:'future_convention_type'
    EUR_OPT:'future_convention_type'
    FFUND:'future_convention_type'
    GILT:'future_convention_type'
    HSX:'future_convention_type'
    IB30D:'future_convention_type'
    IGB:'future_convention_type'
    IMM:'future_convention_type'
    IMM20_CDS_3M:'future_convention_type'
    IMM20_CDS_6M:'future_convention_type'
    IMM_20:'future_convention_type'
    IMM_AUD:'future_convention_type'
    IMM_AUD_15:'future_convention_type'
    IMM_CAD:'future_convention_type'
    IMM_FMG:'future_convention_type'
    IMM_NZD:'future_convention_type'
    IMM_TGB:'future_convention_type'
    IRMC:'future_convention_type'
    IRMC_CME:'future_convention_type'
    JGB:'future_convention_type'
    JGBMini:'future_convention_type'
    JGB_OPT:'future_convention_type'
    KTB:'future_convention_type'
    LAST:'future_convention_type'
    NONE:'future_convention_type'
    SGX_FX:'future_convention_type'
    SGX_FX_ME:'future_convention_type'
    SGX_SORA:'future_convention_type'
    SOFRQ:'future_convention_type'
    SOM:'future_convention_type'
    SONIA:'future_convention_type'
    SONIA3M:'future_convention_type'
    STER_OPT:'future_convention_type'
    SXS5BPI:'future_convention_type'
    TBILL:'future_convention_type'
    TONA3M:'future_convention_type'
    TOTEM:'future_convention_type'
    UST:'future_convention_type'
    USTShort:'future_convention_type'
    UST_OPT:'future_convention_type'
    UST_OPT_1MO:'future_convention_type'
    UST_OPT_1W:'future_convention_type'
    UST_OPT_1WE:'future_convention_type'
    UST_OPT_2MO:'future_convention_type'
    UST_OPT_2W:'future_convention_type'
    UST_OPT_2WE:'future_convention_type'
    UST_OPT_3MO:'future_convention_type'
    UST_OPT_3W:'future_convention_type'
    UST_OPT_3WE:'future_convention_type'
    UST_OPT_4MO:'future_convention_type'
    UST_OPT_4W:'future_convention_type'
    UST_OPT_4WE:'future_convention_type'
    UST_OPT_5MO:'future_convention_type'
    UST_OPT_5W:'future_convention_type'
    UST_OPT_5WE:'future_convention_type'
    _1FRI:'future_convention_type'
    _2FRI:'future_convention_type'
    _2THU:'future_convention_type'
    _3FRI:'future_convention_type'
    _3THU:'future_convention_type'
    end_of_month:'future_convention_type'

class future_date_type(int):
    FDT_EXPIRY:'future_date_type'
    FDT_FIRST_DELIVERY:'future_date_type'
    FDT_FIRST_NOTICE:'future_date_type'
    FDT_FIXING_START_DATE:'future_date_type'
    FDT_LAST_TRADING:'future_date_type'

class index_type(int):
    BOND:'index_type'
    BONDBROKERPRICE:'index_type'
    CMD:'index_type'
    CMS:'index_type'
    CMSFB:'index_type'
    CMT:'index_type'
    COMPINDEX:'index_type'
    COUPONBOND:'index_type'
    CREDIT:'index_type'
    DV01:'index_type'
    DYNA:'index_type'
    DYNAAD:'index_type'
    ECONDATA:'index_type'
    EQ:'index_type'
    FUT:'index_type'
    FUTADJUST:'index_type'
    FX:'index_type'
    INFLATION:'index_type'
    LIBOR:'index_type'
    LIBORFB:'index_type'
    LIBORFXADJUST:'index_type'
    MKTTA:'index_type'
    MUNI:'index_type'
    MUNIBONDYIELD:'index_type'
    OIS:'index_type'
    OISCMS:'index_type'
    OISFXADJUST:'index_type'
    SWAPTION:'index_type'
    TNAP:'index_type'
    UNDEF:'index_type'
    ZEROCOUPON:'index_type'

class iso_type(int):
    ISO8601_DATE:'iso_type'
    ISO8601_DATETIME:'iso_type'
    ISO8601_DATETIME_MILLIS:'iso_type'
    ISO8601_TIME:'iso_type'
    ISO8601_TIME_MILLIS:'iso_type'

class month_type(int):
    APRIL:'month_type'
    AUGUST:'month_type'
    DECEMBER:'month_type'
    FEBRUARY:'month_type'
    INVALID:'month_type'
    JANUARY:'month_type'
    JULY:'month_type'
    JUNE:'month_type'
    MARCH:'month_type'
    MAY:'month_type'
    NOVEMBER:'month_type'
    OCTOBER:'month_type'
    SEPTEMBER:'month_type'

class tenor_unit(int):
    BUSINESS_DAY:'tenor_unit'
    DAY:'tenor_unit'
    INVALID:'tenor_unit'
    MONTH:'tenor_unit'
    WEEK:'tenor_unit'
    YEAR:'tenor_unit'

class volatility_type(int):
    LOG_NORMAL:'volatility_type'
    NORMAL:'volatility_type'
    PARAMETRIC:'volatility_type'

class week_day_type(int):
    FRIDAY:'week_day_type'
    INVALID:'week_day_type'
    MONDAY:'week_day_type'
    SATURDAY:'week_day_type'
    SUNDAY:'week_day_type'
    THURSDAY:'week_day_type'
    TUESDAY:'week_day_type'
    WEDNESDAY:'week_day_type'

class zabr_output_type(int):
    CDF:'zabr_output_type'
    DENSITY:'zabr_output_type'
    IMPLIED_VOLATILITY:'zabr_output_type'
    PRICES:'zabr_output_type'

EXERCISE:'option_date'
UNADJUSTED_EXERCISE:'option_date'

class scheduleInterface(object):
    def flat_schedule(self) -> 'scheduleInterface': ...
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class dateScheduleInterface(scheduleInterface):
    def cached_elems(self) -> Tuple['datetime', 'datetime']: ...
    def elements(self) -> Tuple['datetime', 'datetime']: ...
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class adjustedDateSchedule(dateScheduleInterface): ...

class periodScheduleInterface(scheduleInterface):
    def cached_elems(self) -> Tuple['dateTimePeriod', 'dateTimePeriod']: ...
    def elements(self) -> Tuple['dateTimePeriod', 'dateTimePeriod']: ...
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class adjustedPeriodSchedule(periodScheduleInterface): ...

class analyticalSigmaVolatility(object):
    @overload
    def asv(strike:float, fwd:float, adjustement_inv:float, ctrl:float, atm:float, skew:float, smile:float, put_call:float, legacy_parametresation:bool) -> float: ...
    @overload
    def asv(self, vols:'vector_IdE', strikes:'vector_IdE', legacy_parametresation:bool=False) -> None: ...
    def asv_components(self, strike:float, atm_component:float, skew_component:float, smile_component:float, put_component:float, call_component:float, legacy_parametresation:bool=False) -> None: ...
    def asv_re_anchor_strike(self, new_anchor_strike:float, new_atm:float, new_skew:float, new_smile:float, new_put:float, new_call:float, legacy_parametresation:bool=False) -> None: ...
    def asv_with_sensitivities(self, strikes:'vector_IdE', vols:'vector_IdE', atm_sensitivity:'vector_IdE', skew_sensitivity:'vector_IdE', smile_sensitivity:'vector_IdE', put_sensitivity:'vector_IdE', call_sensitivity:'vector_IdE', strike_sensitivity:'vector_IdE', anchor_strike_sensitivity:'vector_IdE', atm2_sensitivity:'vector_IdE', anchor_strike2_sensitivity:'vector_IdE', strike2_sensitivity:'vector_IdE', legacy_parametresation:bool=False) -> None: ...
    def calibrate(self, market_vols:'vector_IdE', strikes:'vector_IdE') -> 'analyticalSigmaVolatility': ...

class bachelier(object):
    def delta(spot:float, forward:float, strike:float, expiry:float, volatility:float, numeraire:float, is_call:float) -> float: ...
    def gamma(spot:float, forward:float, strike:float, expiry:float, volatility:float, numeraire:float) -> float: ...
    def implied_volatility(forward:float, strike:float, expiry:float, price:float, numeraire:float, is_call:float) -> float: ...
    def price(forward:float, strike:float, expiry:float, volatility:float, numerair:float, is_call:float) -> float: ...
    def vega(forward:float, strike:float, expiry:float, volatility:float, numeraire:float) -> float: ...

class blackScholes(object):
    def delta(forward:float, strike:float, expiry:float, volatility:float, is_call:float) -> float: ...
    def density(forward:float, strike:float, expiry:float, volatility:float, dvol_dK:float, d2vol_dK2:float) -> float: ...
    def gamma(forward:float, strike:float, expiry:float, volatility:float) -> float: ...
    def implied_volatility(forward:float, strike:float, expiry:float, price:float, numeraire:float, call_or_put:float, tolerance:float=..., max_iteration:int=20) -> float: ...
    def price(forward:float, strike:float, expiry:float, volatility:float, numeraire:float, is_call:float) -> float: ...
    def probability(forward:float, strike:float, expiry:float, volatility:float, dvol_dK:float) -> float: ...
    def vega(forward:float, strike:float, expiry:float, volatility:float): ...

class calendar(object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __a:str) -> None: ...
    @overload
    def __init__(self, use_weekends:bool) -> None: ...
    @overload
    def __init__(self, dates:MutableSequence['datetime'], use_weekends:bool) -> None: ...
    @overload
    def __init__(self, __a:'calendar') -> None: ...
    def add_business_days(self, from_:'datetime', busDays:int) -> 'datetime': ...
    def is_business_day(self, date:'datetime') -> bool: ...
    def json_to_string(rhs:'calendar') -> str: ...
    def next_business_day(self, date:'datetime') -> 'datetime': ...
    def number_of_busniness_days(self, from_date:'datetime', to_date:'datetime') -> int: ...
    def previous_business_day(self, date:'datetime') -> 'datetime': ...
    def read_from_binary(file_name:str) -> 'calendar': ...
    def read_from_json(file_name:str) -> 'calendar': ...
    def write_to_binary(file_name:str, rhs:'calendar') -> None: ...
    def write_to_json(file_name:str, rhs:'calendar') -> None: ...

class dateAdjustment(object):
    def adjust(self, base_date:'datetime') -> 'datetime': ...
    def advance(self, d:'datetime', t:'tenor', end_of_month:bool=False) -> 'datetime': ...

class dateAdjustmentFromConvention(dateAdjustment):
    def adjust(self, d:'datetime') -> 'datetime': ...

class dateAdjustmentWeekday(dateAdjustment):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentRollAfterWeekDay(dateAdjustmentWeekday):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentRollBeforeWeekDay(dateAdjustmentWeekday):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentRollDay(dateAdjustment):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentRollLastWeekDay(dateAdjustmentWeekday):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentRollNthWeekday(dateAdjustmentWeekday):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentRollSameWeekDay(dateAdjustmentWeekday):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateAdjustmentSequence(dateAdjustment):
    def adjust(self, base_date:'datetime') -> 'datetime': ...

class dateSchedule(dateScheduleInterface): ...

class dateScheduleFromPeriodSchedule(dateScheduleInterface): ...

class dateScheduleGenerator(dateScheduleInterface):
    def is_stub_period(self, start:'datetime', end:'datetime') -> bool: ...

class dateScheduleUnion(dateScheduleInterface): ...

class dateTimePeriod(object):
    def to_string(self) -> str: ...

class datetime(object):
    @overload
    def __init__(self, data:float=...) -> None: ...
    @overload
    def __init__(self, __a:'datetime') -> None: ...
    def as_float(self) -> float: ...
    def day_fraction(self) -> float: ...
    def empty(self) -> bool: ...
    def is_weekend(self) -> bool: ...
    def next_or_same(self, wd:'weekDayType') -> 'datetime': ...
    def previous_or_same(self, wd:'weekDayType') -> 'datetime': ...
    def serial(self) -> int: ...
    def to_string(self) -> str: ...
    def week_day(self) -> 'weekDayType': ...

class datetimeHelper(object):
    def add_tenor(d:'datetime', t:'tenor', multiplier:int=1) -> 'datetime': ...
    def credit_imm_date(d:'datetime', months_in_period:int=3, day_of_month:int=20) -> 'datetime': ...
    def is_date(str:str) -> bool: ...
    def is_leap_year(year:int) -> bool: ...
    def is_same_day(d:int, roll_day:int) -> bool: ...
    def month_length(month:int, leap_year:bool) -> int: ...
    def nearst_imm_dates(start_date:'datetime', months_in_period:int=3, day_of_week:'weekDayType'=..., n:int=3, is_week:bool=True) -> 'datetime': ...
    def next_imm_date(start_date:'datetime', months_in_period:int=3, day_of_week:'weekDayType'=..., n:int=3, is_week:bool=True) -> 'datetime': ...
    def next_weekend_days(day:'weekDayType', forward_search:bool) -> int: ...

class dayCountConvention(object):
    def fraction(self, start:'datetime', end:'datetime') -> float: ...
    def json_to_string(rhs:'dayCountConvention') -> str: ...
    def read_from_binary(file_name:str) -> 'dayCountConvention': ...
    def read_from_json(file_name:str) -> 'dayCountConvention': ...
    def schedule(self) -> 'calendar': ...
    def write_to_binary(file_name:str, rhs:'dayCountConvention') -> None: ...
    def write_to_json(file_name:str, rhs:'dayCountConvention') -> None: ...

class fixedCouponDates(object): ...

class fixedCouponScheduleInterface(scheduleInterface):
    def cached_elems(self) -> Tuple['fixedCouponDates', 'fixedCouponDates']: ...
    def elements(self) -> Tuple['fixedCouponDates', 'fixedCouponDates']: ...
    def flat_schedule(self) -> 'scheduleInterface': ...
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class fixedCouponSchedule(fixedCouponScheduleInterface): ...

class fixedCouponScheduleGenerator(fixedCouponScheduleInterface): ...

class flatFixedCouponDates(object): ...

class flatFixedCouponSchedule(fixedCouponScheduleInterface):
    def flat_schedule(self) -> 'scheduleInterface': ...

class flatFloatingCouponDates(flatFixedCouponDates): ...

class floatingCouponScheduleInterface(scheduleInterface):
    def cached_elems(self) -> Tuple['floatingCouponDates', 'floatingCouponDates']: ...
    def elements(self) -> Tuple['floatingCouponDates', 'floatingCouponDates']: ...
    def flat_schedule(self) -> 'scheduleInterface': ...
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class flatFloatingCouponSchedule(floatingCouponScheduleInterface):
    def flat_schedule(self) -> 'scheduleInterface': ...

class observationScheduleInterface(scheduleInterface):
    def cached_elems(self) -> Tuple['periodObservationDates', 'periodObservationDates']: ...
    def elements(self) -> Tuple['periodObservationDates', 'periodObservationDates']: ...
    def flat_schedule(self) -> 'scheduleInterface': ...
    def schedule(self) -> 'scheduleInterface': ...

class flatObservationSchedule(observationScheduleInterface):
    def flat_schedule(self) -> 'scheduleInterface': ...

class flatPeriodObservationDate(object): ...

class floatingCouponDates(fixedCouponDates): ...

class floatingCouponSchedule(floatingCouponScheduleInterface): ...

class floatingCouponScheduleGenerator(floatingCouponScheduleInterface): ...

class key(object):
    @overload
    def __init__(self, name:str) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __a:'key') -> None: ...
    @overload
    def hash(self) -> int: ...
    @overload
    def hash(a:'key', b:int) -> int: ...
    def to_string(self) -> str: ...

class monthDayYear(object):
    def is_end_of_month(self, ignore_leap_years:bool=False) -> bool: ...
    def month_length(self, ignore_leap_years:bool=False) -> int: ...
    def normalize(self) -> None: ...
    def to_datetime(self) -> 'datetime': ...
    @overload
    def to_string(self, format:'isoType'=...) -> str: ...
    @overload
    def to_string(self, format:str) -> str: ...
    def week_day(self) -> 'weekDayType': ...

class observationSchedule(observationScheduleInterface): ...

class onOrBeforeObservationSchedule(observationScheduleInterface): ...

class optionDates(object): ...

class optionScheduleInterface(scheduleInterface):
    def check(self, enforce_strict_ordering:bool) -> None: ...
    def exercise_dates(self) -> Tuple['datetime', 'datetime']: ...
    def notification_dates(self) -> Tuple['datetime', 'datetime']: ...
    def setup(self) -> None: ...
    def size(self) -> int: ...

class optionSchedule(optionScheduleInterface):
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class optionScheduleGenerator(optionScheduleInterface):
    class option_date(int): ...
    EXERCISE:'option_date'
    UNADJUSTED_EXERCISE:'option_date'
    def schedule(self) -> 'scheduleInterface': ...
    def setup(self) -> None: ...

class periodObservationDates(object): ...

class periodSchedule(periodScheduleInterface): ...

class periodScheduleGenerator(periodScheduleInterface): ...

class relativeObservationSchedule(observationScheduleInterface): ...

class sabrAnalytics(object):
    def price(forward:float, strike:float, expiry:float, numeraire:float, is_call:float, alpha:float, beta:float, nu:float, rho:float, shift:float, is_skew_dampening:bool) -> float: ...

class sabrPdeAnalytics(object):
    def Z(self, output:'vector_IdE', strike:'vector_IdE') -> None: ...
    def dZ_dK(self, output:'vector_IdE') -> None: ...
    def density(self) -> 'vector_IdE': ...
    def discretization_step(self) -> float: ...
    def make_forward_grid(self, z:'vector_IdE', j0:int) -> None: ...
    def price(self, strike:float, is_call:bool, type:'densitySmoothingType', smoothing_parameters:Sequence[float]=...) -> float: ...
    def strikes(self) -> 'vector_IdE': ...

class sabrPdeAnalyticsClassic(sabrPdeAnalytics):
    def dZ_dK(self, output:'vector_IdE') -> None: ...

class sabrPdeAnalyticsMixture(sabrPdeAnalytics):
    def dZ_dK(self, output:'vector_IdE') -> None: ...

class sigmaVolatilityInspired(object):
    def calibrate(self, market_vols:'vector_IdE', strikes:'vector_IdE') -> 'sigmaVolatilityInspired': ...
    @overload
    def svi(self, strike:float) -> float: ...
    @overload
    def svi(self, vols:'vector_IdE', strikes:'vector_IdE') -> None: ...
    def svi_with_sensitivities(self, strikes:'vector_IdE', vols:'vector_IdE', atm_sensitivity:'vector_IdE', skew_sensitivity:'vector_IdE', smile_sensitivity:'vector_IdE', strike_sensitivity:'vector_IdE', forward_sensitivity:'vector_IdE', atm2_sensitivity:'vector_IdE', forward2_sensitivity:'vector_IdE', strike2_sensitivity:'vector_IdE') -> None: ...

class surfaceTermStructure(object):
    def at(self, t1:'datetime', t2:'datetime') -> float: ...
    def json_to_string(rhs:'surfaceTermStructure') -> str: ...
    def read_from_binary(file_name:str) -> 'surfaceTermStructure': ...
    def read_from_json(file_name:str) -> 'surfaceTermStructure': ...
    def write_to_binary(file_name:str, rhs:'surfaceTermStructure') -> None: ...
    def write_to_json(file_name:str, rhs:'surfaceTermStructure') -> None: ...

class tenor(object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, n:int, type:'tenorUnit') -> None: ...
    @overload
    def __init__(self, t:str) -> None: ...
    @overload
    def __init__(self, n:int, freq:'frequencyType') -> None: ...
    @overload
    def __init__(self, freq:'frequencyType') -> None: ...
    @overload
    def __init__(self, __a:'tenor') -> None: ...
    def compare(self, rhs:'tenor') -> int: ...
    def empty(self) -> bool: ...
    def has_same_units(self, rhs:'tenor') -> bool: ...
    def is_month_based_interval(self) -> bool: ...
    def n(self) -> int: ...
    def to_string(self) -> str: ...
    def unit(self) -> 'tenorUnit': ...

class windowedObservationSchedule(observationScheduleInterface): ...

class zabrAnalytics(object):
    def density(output:'vector_IdE', prices:'vector_IdE', strikes:'vector_IdE'): ...
    def implied_volatility(self, output:'vector_IdE', strikes:'vector_IdE') -> None: ...
    def sigma(self, strike:float) -> float: ...
    def values(self, output:'vector_IdE', strikes:'vector_IdE', output_type:'zabrOutputType', zero_gamma:bool=True, offsets:Sequence[int]=...) -> None: ...

class zabrClassicalAnalytics(zabrAnalytics):
    def sigma(self, strike:float) -> float: ...

class zabrMixtureAnalytics(zabrAnalytics):
    def calibrate(self, market_vols:Sequence[float], strikes:Sequence[float], n:int=200) -> None: ...
    def sigma(self, strike:float) -> float: ...
    def strike_grid(expiry:float, fwd:float, n:int, calibration_strikes:Sequence[float]=..., m:int=8, alpha:float=0.01, beta:float=0.5, rho:float=0., vol_of_vol:float=1.2, vol_of_vol_lower:float=0.1, vol_of_vol_decay:float=1., vol_of_vol_power:float=1., displacement:float=-0.02, fwd_ref:float=0.1, fwd_decay:float=-12.0, p_min:float=0.01, p_max:float=0.9999, tolerance:float=1.E-7) -> Tuple[float, float]: ...

