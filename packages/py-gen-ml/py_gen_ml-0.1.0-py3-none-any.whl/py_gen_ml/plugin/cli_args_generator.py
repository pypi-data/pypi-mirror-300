from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import TypeVar

import networkx
import protogen

from py_gen_ml.extensions_pb2 import ArgRefs
from py_gen_ml.logging.setup_logger import setup_logger
from py_gen_ml.plugin.common import (
    generate_docstring,
    get_element_subgraphs,
    get_extension_value,
)
from py_gen_ml.plugin.constants import BASE_MODEL_ALIAS, PGML_ALIAS
from py_gen_ml.plugin.generator import Generator
from py_gen_ml.typing.some import some

logger = setup_logger(__name__)

T = TypeVar('T')


@dataclass
class FieldPath:
    """A path to a field in a message."""
    path: list[str]
    field: protogen.Field


class CliArgsGenerator(Generator):
    """
    A generator that creates CLI argument models based on the input protobuf files.

    The generated file will be imported by the py-gen-ml CLI to generate CLI argument models for the given protobuf files.
    """

    def __init__(self, gen: protogen.Plugin, suffix: str) -> None:
        """
        Initialize the CliArgsGenerator.

        Args:
            gen (protogen.Plugin): The protogen plugin instance.
            suffix (str): The suffix to be added to the generated file names.

        This class is responsible for generating CLI argument models based on
        the input protobuf files. It creates pydantic models that can be used
        with typer for command-line interfaces.
        """
        super().__init__(gen)
        self._suffix = suffix

    def _generate_code_for_file(self, file: protogen.File) -> None:
        """
        Generate the args models corresponding to a file.

        Args:
            file (protogen.File): The input file.

        Returns:
            protogen.GeneratedFile: The generated file.
        """
        g = self._gen.new_generated_file(
            file.proto.name.replace('.proto', self._suffix),
            file.py_import_path,
        )
        g.P('# Autogenerated code. DO NOT EDIT.')
        g.P(f'import py_gen_ml as {PGML_ALIAS}')
        g.P('import typing')
        g.P()
        g.P('import pydantic')
        g.P('import typer')
        g.P()

        import_file_path = str(Path(file.proto.name.replace('.proto', '_base')).name)
        g.P(f'from . import {import_file_path} as {BASE_MODEL_ALIAS}')
        g.P()
        g.P()

        dependency_subgraphs = get_element_subgraphs(file)
        for subgraph in dependency_subgraphs:
            for message in networkx.topological_sort(subgraph):
                if not isinstance(message, protogen.Message):
                    continue
                self._generate_message_args(g, message, subgraph)

    def _generate_message_args(
        self,
        g: protogen.GeneratedFile,
        message: protogen.Message,
        graph: networkx.MultiDiGraph,
    ) -> None:
        """
        Generate the 'Args' counterpart of a given message.

        Args:
            g (protogen.GeneratedFile): The generated file to which we append the generated Python code.
            message (protogen.Message): The proto message that we are currently processing.
            graph (networkx.DiGraph): The networkx graph that contains the message.
        """
        descendant_fields = self._gather_descendant_fields(message, graph)
        g.P(f'class {message.proto.name}Args({PGML_ALIAS}.YamlBaseModel):')
        g.set_indent(4)

        generate_docstring(g, message)

        for field_paths in descendant_fields.values():
            if len(field_paths) != 1:
                continue
            field_path = field_paths[0]
            g.P(f'{field_path.field.py_name}: {self.field_to_annotation(field=field_path.field, path=field_path.path)}')
            generate_docstring(g, field_path.field)

        explicit_arg_refs = get_extension_value(message, 'arg_refs', ArgRefs)
        if explicit_arg_refs is not None:
            for arg_ref in explicit_arg_refs.item:
                path = arg_ref.path.split('.')
                field = self._get_field_by_path(message, path)
                g.P(f'{arg_ref.name}: {self.field_to_annotation(field, path)}')
                generate_docstring(g, field)
        g.P()
        g.P()
        g.set_indent(0)

    def _gather_descendant_fields(self, message: protogen.Message,
                                  graph: networkx.MultiDiGraph) -> dict[str, list[FieldPath]]:
        """
        Gathers descendant fields of the given message.

        It goes down the dependency hierarchy to find field names at leaf nodes.

        Args:
            message (protogen.Message): The message of which to find descendant
                fields.
            graph (networkx.MultiDiGraph): A networkx graph that contains the message.

        Returns:
            dict[str, list[FieldPath]]: A mapping of field name to a list FieldPath objects.
        """
        fields = defaultdict[str, list[FieldPath]](list)
        for descendant in [message, *networkx.ancestors(graph, message)]:
            if isinstance(descendant, protogen.Enum):
                continue
            paths = list(networkx.all_simple_paths(graph, source=descendant, target=message))
            if len(paths) != 1:
                continue
            edges = paths[0]
            if len(edges) == 0:
                continue
            path_graph = networkx.path_graph(edges)

            if any(graph.number_of_edges(source, target) > 1 for source, target in path_graph.edges()):
                continue

            path = list[str]()
            for source, target in path_graph.edges():
                path.append(graph.edges[source, target, 0]['field'])  # type: ignore
            descendant: protogen.Message
            for field in descendant.fields:
                if field.kind == protogen.Kind.MESSAGE:
                    continue
                fields[field.py_name].append(FieldPath(path=[*reversed(path), field.py_name], field=field))
        return fields

    def field_to_annotation(self, field: protogen.Field, path: list[str]) -> str:
        """
        Get the annotation for a field and a path.

        The path is what the field maps to in the base model.

        Args:
            field (protogen.Field): Field in the protobuf Message
            path (list[str]): Path to the field in the base model that this field
                maps to.

        Returns:
            list[str]: A list of strings to append.
        """
        annotation = self.field_to_type(field)
        if field.is_list() and len(path) == 0:
            annotation = f'list[{annotation}]'
        typer_option = ''

        if len(path) > 0:
            path_str = '.'.join(path)
            if field.location.leading_comments == '':
                typer_option = f", typer.Option(help=\"Maps to {path_str}.{field.py_name}\")"
            else:
                typer_option = f", typer.Option(help=\"{field.location.leading_comments.rstrip('.')}. Maps to '{path_str}'\")"
            annotation = f"typing.Annotated[typing.Optional[{annotation}]{typer_option}, pydantic.Field(None), {PGML_ALIAS}.ArgRef(\"{path_str}\")]"
        else:
            if field.location.leading_comments == '':
                typer_option = f", typer.Option(help=\"Maps to {field.py_name}\")"
            else:
                typer_option = f", typer.Option(help=\"{field.location.leading_comments.rstrip('.')}. Maps to '{field.py_name}'\")"
            annotation = f'typing.Annotated[typing.Optional[{annotation}]{typer_option}, pydantic.Field(None)]'
        return annotation

    def _get_field_by_path(self, message: protogen.Message, path: list[str]) -> protogen.Field:
        """
        Get the field at a given path in a message.

        Args:
            message (protogen.Message): The message to get the field from.
            path (list[str]): The path to the field.

        Returns:
            protogen.Field: The field at the given path.

        Raises:
            ValueError: The field at the given path was not found.
        """
        for field in message.fields:
            if field.py_name == path[0]:
                if len(path) == 1:
                    return field
                if field.kind == protogen.Kind.MESSAGE:
                    return self._get_field_by_path(some(field.message), path[1:])
        else:
            raise ValueError(f'Field {path[0]} not found in message {message.proto.name}')

    def field_to_type(self, field: protogen.Field) -> str:
        """
        Converts a protogen field to a type.

        Args:
            field (protogen.Field): Field in the proto message.

        Raises:
            ValueError: The field kind is not supported.

        Returns:
            str: A string representation of the type.
        """
        match field.kind:
            case protogen.Kind.MESSAGE:
                return f'{some(field.message).py_ident.py_name}Args'
            case protogen.Kind.DOUBLE:
                return 'float'
            case protogen.Kind.FLOAT:
                return 'float'
            case protogen.Kind.INT64:
                return 'int'
            case protogen.Kind.UINT64:
                return 'int'
            case protogen.Kind.INT32:
                return 'int'
            case protogen.Kind.FIXED64:
                return 'int'
            case protogen.Kind.FIXED32:
                return 'int'
            case protogen.Kind.BOOL:
                return 'bool'
            case protogen.Kind.STRING:
                return 'str'
            case protogen.Kind.BYTES:
                return 'bytes'
            case protogen.Kind.UINT32:
                return 'int'
            case protogen.Kind.ENUM:
                return f'{BASE_MODEL_ALIAS}.{some(field.enum).py_ident.py_name}'
            case protogen.Kind.SFIXED32:
                return 'int'
            case protogen.Kind.SFIXED64:
                return 'int'
            case protogen.Kind.SINT32:
                return 'int'
            case protogen.Kind.SINT64:
                return 'int'
            case _:
                raise ValueError(f'Unknown field kind: {field.kind}')
