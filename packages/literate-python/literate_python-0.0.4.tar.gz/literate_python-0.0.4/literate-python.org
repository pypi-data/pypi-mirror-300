# -*- Mode: POLY-ORG ; common-lisp-style: elisp; indent-tabs-mode: nil;  -*- ---
#+Title: Develop Python modules in Org files.
#+OPTIONS: tex:verbatim toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STARTUP: latexpreview
#+STARTUP: noindent
#+STARTUP: inlineimages
#+PROPERTY: literate-lang python
#+PROPERTY: literate-load yes
#+PROPERTY: literate-insert-header no
#+PROPERTY: header-args :results silent :session :tangle no
#+PROPERTY: LITERATE_PYTHON_EXPORT_DIRECTORY: ./literate_python
* Table of Contents                                            :noexport:TOC:
- [[#introduction][Introduction]]
- [[#a-minor-mode-for-literate-python][A minor mode for literate python]]
  - [[#definition][definition]]
  - [[#black-org-code-block-when-save][black org code block when save]]
  - [[#black-all-org-code-blocks-in-current-buffer][black all org code blocks in current buffer]]
  - [[#tangle-current-file-when-save][tangle current file when save]]
  - [[#xref-backend][xref backend]]
    - [[#backend-name][backend name]]
    - [[#identifier-completion-table][identifier-completion-table]]
    - [[#collect-definitions-in-an-org-file][collect definitions in an org file]]
    - [[#find-definitions][find definitions]]
    - [[#utilities][utilities]]
- [[#python-library-for-a-literate-server][Python library for a literate server]]
  - [[#idea][Idea]]
  - [[#prototype][Prototype]]
  - [[#module-layout-in-an-org-file][Module Layout in an Org file]]
  - [[#implementation-in-python-side][Implementation in python side]]
    - [[#__init__][__init__]]
    - [[#__main__][__main__]]
    - [[#literate-module-loader][literate module loader]]
    - [[#web-server][web server]]
- [[#the-emacs-library][The Emacs library]]
  - [[#import-required-elisp-libraries][Import required elisp libraries]]
  - [[#utilities-1][Utilities]]
    - [[#connect-to-a-literate-server][connect to a literate server]]
    - [[#send-request-to-remote-literate-server][send request to remote literate server]]
  - [[#register-literate-modules][Register literate modules]]
    - [[#register-literate-modules-1][register literate modules]]
    - [[#register-modules-for-code-blocks-under-current-point][register modules for code blocks under current point]]
  - [[#source-code-execution][Source Code Execution]]
    - [[#customized-variables-for-server-host-and-port][customized variables for server host and port]]
    - [[#execute-source-codes-in-specified-module-for-org-babel-python-evaluate][execute source codes in specified module for org-babel-python-evaluate]]
    - [[#execute-source-code-in-remote-server][execute source code in remote server]]
    - [[#execute-source-code-in-current-code-block][execute source code in current code block]]
    - [[#get-top-level-python-code][get top level python code]]
    - [[#get-the-module-name-for-a-file-name][get the module name for a file name]]
    - [[#load-python-code-to-current-module][load python code to current module]]
  - [[#register-python-modules][register python modules]]
- [[#python-inspector-for-emacs][Python inspector for Emacs]]
  - [[#package-for-python-inspector][Package for python inspector]]
- [[#sync-between-org-files-and-python-files][Sync between org files and python files]]
  - [[#introduction-1][Introduction]]
  - [[#import][Import]]
    - [[#how][How]]
    - [[#implementation][Implementation]]
  - [[#export][Export]]
- [[#run-python-code-in-specified-module][Run python code in specified module]]
  - [[#setup-current-module-in-python-repl][setup current module in python REPL]]
    - [[#a-special-variable-for-current-module-name-in-python-repl][a special variable for current module name in python REPL]]
    - [[#display-namespace-in-the-mode-line-in-buffer-for-python-repl][display namespace in the mode line in buffer for python REPL]]
    - [[#a-comint-input-sender-to-exec-code-in-a-namespace][a comint input sender to exec code in a namespace.]]
  - [[#setup-python-shell-eval-setup-code][setup python shell eval setup code]]
- [[#tips][Tips]]
  - [[#how-to-start-django-server-in-repl][how to start django server in REPL]]
- [[#todo01][TODO]]
- [[#references][References]]

* Introduction
I have used an org file to write my document and code for a long time, in various languages.

It is very convenient to write code in an org file.
For example, instead of managing multiple files in nested directories,
I can write code in an org file with a clear structure in a more lightweight way.
Also, it can contain both documentation and code in one file for all my projects.

Now I want to use org file to write Python code,
and I want to import Python modules from an org file for my projects.

So comes this library to help me import Python modules from org files in Emacs.
* A minor mode for literate python
:PROPERTIES:
:literate-lang: elisp
:header-args: :results silent :session :tangle no
:END:
** definition
#+BEGIN_SRC elisp
(define-minor-mode literate-python-mode
    "Mode for org buffers with code blocks."
  :lighter nil
  (cond
    (literate-python-mode
     (when (equal "org" (f-ext (buffer-file-name (current-buffer))))
       (when (buffer-base-buffer)
         (with-current-buffer (buffer-base-buffer)
           ;; The command `save-buffer` utilizes the base buffer for an indirect buffer.
           (add-hook 'before-save-hook 'literate-python-black-org-code-block -50 t)
           (add-hook 'after-save-hook 'literate-python-tangle-current-file -50 t)
           (add-hook 'xref-backend-functions #'literate-python-xref-backend -50 t)))))
    (t
     (when (equal "org" (f-ext (buffer-file-name (current-buffer))))
       (when (buffer-base-buffer)
         (with-current-buffer (buffer-base-buffer)
           (remove-hook 'before-save-hook 'literate-python-black-org-code-block t)
           (remove-hook 'after-save-hook 'literate-python-tangle-current-file t)))
       (remove-hook 'xref-backend-functions #'literate-python-xref-backend t)))))
#+END_SRC
** black org code block when save
#+BEGIN_SRC elisp
(defun literate-python-black-org-code-block ()
  (when (org-in-block-p '("src")) 
    (let ((language (getf (second (org-element-at-point)) :language)))
      (when (find language '("python" "ipython") :test #'equalp)
        (python-black-org-mode-block t)))))
#+END_SRC
** black all org code blocks in current buffer
#+BEGIN_SRC elisp
(defun literate-python-black-org-code-blocks-in-current-buffer ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "#\\+BEGIN_SRC python" nil t)
      (forward-line 1)
      (unless (string-prefix-p "#+END_SRC" (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
        (literate-python-black-org-code-block)))))
#+END_SRC
** tangle current file when save
#+BEGIN_SRC elisp
(defun literate-python-tangle-current-file ()
  (interactive)
  (when-let ((file-name (cdr (assoc :tangle (cl-third (org-babel-get-src-block-info 'light))))))
   (org-babel-tangle '(16) file-name (f-ext file-name))))
#+END_SRC
** xref backend
*** backend name
#+BEGIN_SRC elisp
(defun literate-python-xref-backend ()
  'xref-literate-python)
#+END_SRC
*** identifier-completion-table
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-identifier-completion-table ((_backend (eql xref-literate-python)))
  (xref-backend-identifier-completion-table 'xref-lsp))
#+END_SRC
*** collect definitions in an org file
**** a variable to store all definitions
#+BEGIN_SRC elisp
(defvar literate-python-org-code-definitions nil)
#+END_SRC
**** parse all python code blocks
#+BEGIN_SRC elisp
(defun my-parse-python-blocks ()
    "Parse all Python source blocks in the current Org file and collect definitions."
    (let (results)
      (org-element-map (org-element-parse-buffer) 'src-block
        (lambda (src-block)
          (when (string= "python" (org-element-property :language src-block))
            (let* ((code (org-element-property :value src-block))
                   (tree (tree-sitter-parse-string 'python code))
                   (root (tree-sitter-root-node tree)))
              (setq results (append results (my-collect-definitions root code)))))))
      results))
#+END_SRC

*** find definitions
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-definitions ((_backend (eql xref-literate-python)) identifier)
  (let ((current-point (point)))
    (save-excursion
      ;; `save-buffer' will tangle code blocks for current file.
      (save-buffer)
      ;; reach to the start of a python file.
      (search-backward-regexp "^:header-args: :tangle .*?\\.py")
      (xref-backend-definitions 'xref-lsp identifier))))
#+END_SRC
*** utilities
#+BEGIN_SRC elisp
(defun literate-python-get-point-in-tangled-file ()
  (let ((current-point (point)))
    (save-excursion
      ;; `save-buffer' will tangle code blocks for current file.
      (save-buffer)
      ;; reach to the start of a python file.
      (search-backward-regexp "^:header-args: :tangle .*?\\.py")
      (point))))
#+END_SRC

* Python library for a literate server
:PROPERTIES:
:header-args: :results silent :session :tangle no
:END:
** Idea
Python has a flexible module import system that allows you to customize how modules are imported.
This enables us to import modules from a different file format (e.g. an org file).

This approach allows you to maintain and organize your Python code blocks in different modules within one .org file
while dynamically loading it into Python’s namespace.
It leverages Emacs’ powerful editing capabilities along with
Python’s flexible import system to create a seamless workflow for developing and running Python code.

We also provide a way to execute Python code blocks in org files within specified Python modules,
to allow for a more interactive development experience.
** Prototype
:PROPERTIES:
:header-args: :results silent :session :tangle no
:END:
Let's do some tests in Python.

1. import the necessary modules
#+BEGIN_SRC python
import sys
import importlib
#+END_SRC

2. create a new module dynamically
#+BEGIN_SRC python
spec_module_a = importlib.util.spec_from_loader("module_a", loader=None)
module_a = importlib.util.module_from_spec(spec_module_a)
sys.modules["module_a"] = module_a
#+END_SRC

3. add a function to the module
#+BEGIN_SRC python
exec('def say_hello(): print("Hello from module_a.")', module_a.__dict__)
exec('def a(): return 3', module_a.__dict__)
exec('def b(): return 4 + a()', module_a.__dict__)
#+END_SRC
4. run this function
#+BEGIN_SRC python
from module_a import say_hello
from module_a import b
say_hello()
b()
#+END_SRC

It works well.
** Module Layout in an Org file
We can organize Python code blocks in org files in the following way:
- The org sections are used to separate different modules.
  - The org sections has the same hierarchy as the Python modules.
  - The Python module name is defined in the property with name =LITERATE_PYTHON_MODULE= in the section.
- The Python code blocks in each section are used to define the functions and classes in the module.
- A code block is loaded conditionally by the org property =LITERATE_PYTHON_LOAD= or header argument =load=.
    - The property is not set.
    - The property is set to =yes=.
    - The property is found in the environment =LITERATE_PYTHON_LOAD=.

For example      
#+BEGIN_EXAMPLE
 * Module A
   :PROPERTIES:
   :LITERATE_PYTHON_MODULE: module_a
   :END:
  ** Module A.a
   :PROPERTIES:
   :LITERATE_PYTHON_MODULE: module_a.a
   :END:
  *** a function for module A.a
   ,#+BEGIN_SRC python
   def say_hello():
        print("Hello from module_a.a.")
   ,#+END_SRC
  *** a test code for above function
   ,#+BEGIN_SRC python :load test
   say_hello()
   ,#+END_SRC
#+END_EXAMPLE
** Implementation in python side
:PROPERTIES:
:LITERATE_PYTHON_MODULE: literate_python
:LITERATE_PYTHON_ROOT_MODULE_PATH: ./
:END:
*** __init__
:PROPERTIES:
:LITERATE_PYTHON_MODULE: literate_python.__init__
:header-args: :tangle ./literate_python/__init__.py
:END:
**** Assignment __version__
#+BEGIN_SRC python
__version__ = "0.0.4"

#+END_SRC
*** __main__
:PROPERTIES:
:LITERATE_PYTHON_MODULE: literate_python.__main__
:header-args: :tangle ./literate_python/__main__.py
:END:
**** Import statements
#+BEGIN_SRC python
from .pipe import run_server

#+END_SRC
**** Call run_server
#+BEGIN_SRC python
run_server()

#+END_SRC
*** literate module loader
:PROPERTIES:
:LITERATE_PYTHON_MODULE: literate_python.loader
:header-args: :tangle ./literate_python/loader.py
:END:
**** Import statements
#+BEGIN_SRC python
import sys
import types
import importlib
import importlib.abc
import importlib.machinery
import logging
import orgparse

#+END_SRC
**** logger
#+BEGIN_SRC python
logger = logging.getLogger(__name__)

#+END_SRC
**** in-memory module storage
***** the global parameter
#+BEGIN_SRC python
if "inMemoryModules" not in globals():
    inMemoryModules = {}

#+END_SRC
***** a method to register a list of modules
#+BEGIN_SRC python
def register_literate_modules(module_spec_list: list) -> None:
    for module_spec in module_spec_list:
        inMemoryModules[module_spec["name"]] = module_spec

#+END_SRC
**** find a module
#+BEGIN_SRC python
def _get_module_spec(fullname: str) -> bool:
    return inMemoryModules.get(fullname) or inMemoryModules.get(fullname + ".__init__")

#+END_SRC

**** a literate module importer
#+BEGIN_SRC python
class LiterateImporter(object):
    def find_module(self, fullname: str, path=None):
        if _get_module_spec(fullname):
            logger.debug(f"Found literate module {fullname}")
            return self
        else:
            return None

    def load_module(self, fullname: str):
        """Create a new module object."""
        mod_spec = _get_module_spec(fullname)
        mod = types.ModuleType(fullname)
        mod.__loader__ = self
        mod.__file__ = mod_spec.get("filepath", "")
        # Set module path - get filepath and keep only the path until filename
        mod.__path__ = ["/".join(mod.__file__.split("/")[:-1]) + "/"]
        mod.__package__ = fullname
        sys.modules[fullname] = mod
        # Execute the module/package code into the Module object
        logger.debug(f"Load literate module {fullname}")
        exec(mod_spec["content"], mod.__dict__)
        return mod

#+END_SRC
**** Register the Loader with the Import System
#+BEGIN_SRC python
class LiterateModuleFinder(importlib.abc.MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        if _get_module_spec(fullname):
            logger.debug(f"Found literate module {fullname}")
            return importlib.machinery.ModuleSpec(fullname, LiterateImporter())
        return None

#+END_SRC
**** a routine to register the finder
#+BEGIN_SRC python
def register_literate_module_finder():
    sys.meta_path = [
        f for f in sys.meta_path if not isinstance(f, LiterateModuleFinder)
    ]
    print("Register literate importer.\n")
    sys.meta_path.append(LiterateModuleFinder())

#+END_SRC
**** operations with org files
***** load python modules from an org file
#+BEGIN_SRC python
def load_literate_modules_from_org_file(org_file: str) -> None:
    org = orgparse.load(org_file)

#+END_SRC
***** load literate modules form org nodes
#+BEGIN_SRC python
def load_literate_modules_from_org_node(node: orgparse.OrgNode) -> None:
    root_module = LITERATE_PYTHON_ROOT_MODULE

#+END_SRC

***** build an org model compatible string from a local python package
#+BEGIN_SRC python
def build_org_model_from_local_python_package(package_path: str) -> str:
    pass

#+END_SRC

*** web server
:PROPERTIES:
:LITERATE_PYTHON_MODULE: literate_python.server
:header-args: :tangle ./literate_python/server.py
:END:
**** Import statements
#+BEGIN_SRC python
import importlib
import os
import sys
import time
import json
from flask import Flask, request, jsonify

import traceback
import builtins

# To convert lisp ratio to python
import fractions
from contextlib import redirect_stdout
from contextlib import redirect_stderr
from io import StringIO
from io import StringIO

import logging

from textwrap import shorten
from literate_python.loader import (
    register_literate_modules,
    register_literate_module_finder,
)

from literate_python.inspector import _inspect

#+END_SRC
**** Assignment logger
#+BEGIN_SRC python
logger = logging.getLogger(__name__)

#+END_SRC
**** Assignment app
#+BEGIN_SRC python
app = Flask(__name__)

#+END_SRC
**** ensure a module is loaded
#+BEGIN_SRC python
def ensure_module(module_name, module_create_method):
    """Ensure a module is loaded and return it."""
    if module_name in sys.modules:
        return sys.modules[module_name]

    match module_create_method:
        case "create":
            spec_module = importlib.util.spec_from_loader(module_name, loader=None)
            module = importlib.util.module_from_spec(spec_module)
            sys.modules[module_name] = module
            return module
        case "import":
            importlib.import_module(module_name)
            return sys.modules[module_name]
        case "import_or_create":
            if importlib.util.find_spec(module_name):
                importlib.import_module(module_name)
                return sys.modules[module_name]
            else:
                spec_module = importlib.util.spec_from_loader(module_name, loader=None)
                module = importlib.util.module_from_spec(spec_module)
                sys.modules[module_name] = module
                return module
        case _:
            msg = f"Module {module_create_method} doesn't exist"
            raise ValueError(msg)

#+END_SRC

**** Function process_a_message
#+BEGIN_SRC python
def process_a_message(message):
    stdout_stream = StringIO()
    stderr_stream = StringIO()
    error = None
    result = None
    with redirect_stdout(stdout_stream):
        with redirect_stderr(stderr_stream):
            try:
                type = message["type"]
                code = message["code"]
                dict = globals()
                module_name = message["module"] if "module" in message else None
                if module_name:
                    module_create_method = message.get("module-create-method", "import")
                    module = ensure_module(module_name, module_create_method)
                    dict = module.__dict__

                if error is None:
                    if type == "eval":
                        exec(compile(code, module_name or "code", "exec"), dict)
                        result_name = message.get("result-name", "_")
                        result = dict.get("_", None)
                    elif type == "exec":
                        result = exec(
                            compile(code, module_name or "code", "exec"), dict
                        )
                        logger.debug("Executed code: %s,result:%s", code, result)
                    elif type == "quit":
                        result = None
                    else:
                        error = "Unknown type: {}".format(type)
                        raise ValueError(error)
            except Exception as e:
                # printing stack trace
                traceback.print_exc()
                error = str(e)
    if error is None:
        return_value = {
            "result": _inspect(result),
            "type": "result",
            "stdout": stdout_stream.getvalue(),
            "stderr": stderr_stream.getvalue(),
        }
    else:
        return_value = {
            "error": error,
            "type": "error",
            "stdout": stdout_stream.getvalue(),
            "stderr": stderr_stream.getvalue(),
        }

    if type == "quit":
        sys.exit(0)
    else:
        return return_value

#+END_SRC
**** register in memory python modules 
**** register
#+BEGIN_SRC python
def register(request):
    # Get JSON data
    data = request.get_json()

    # Process the data (example)
    logger.debug(
        "/register Received:%s", shorten(str(data), width=100, placeholder="...")
    )
    try:
        register_literate_modules(data)
        return_value = {"type": "done"}
    except Exception as e:
        # printing stack trace
        return_value = {"type": "error", "stderr": str(e)}
        traceback.print_exc()

    # Return a response
    logger.debug("/register Returning:%s", return_value)
    return jsonify(return_value)

#+END_SRC

**** @app.route('/lpy/register, methods=['POST']): register literate modules
#+BEGIN_SRC python
@app.route("/lpy/register", methods=["POST"])
def register_router():
    return register(request)

#+END_SRC
**** execute
#+BEGIN_SRC python
def _execute(request):
    # Get JSON data
    data = request.get_json()

    # Process the data (example)
    logger.debug(
        "/execute Received:%s", shorten(str(data), width=100, placeholder="...")
    )
    return_value = process_a_message(data)

    # Return a response
    logger.debug("/execute Returning:%s", return_value)
    return jsonify(return_value)

#+END_SRC

**** @app.route('/execute', methods=['POST']): Function execute
#+BEGIN_SRC python
@app.route("/lpy/execute", methods=["POST"])
def execute():
    return _execute(request)

#+END_SRC

**** status
#+BEGIN_SRC python
def _status(request):
    return jsonify({"status": "ok"})

#+END_SRC

**** status router
#+BEGIN_SRC python
@app.route("/lpy/status", methods=["GET"])
def status():
    return _status(request)

#+END_SRC

**** Function run_web_server
#+BEGIN_SRC python
def run_server():
    host = "127.0.0.1"
    port = 7330
    if "LITERATE_PYTHON_HOST" in os.environ:
        host = os.environ["LITERATE_PYTHON_HOST"]
    if "LITERATE_PYTHON_PORT" in os.environ:
        port = int(os.environ["LITERATE_PYTHON_PORT"])
    register_literate_module_finder()
    app.run(debug=True, port=port, host=host, use_reloader=False)

#+END_SRC

* The Emacs library
:PROPERTIES:
:literate-lang: elisp
:END:
** Import required elisp libraries
#+BEGIN_SRC elisp
(require 'f)
(require 'files)
(require 'ob-python)
(require 'lsp);; for `lsp-workspace-root'
(require 'python-black)
#+END_SRC

** Utilities
*** connect to a literate server
#+BEGIN_SRC elisp
(defun literate-python-connect ()
  (interactive)
  (when-let* ((url (read-from-minibuffer "URL: " literate-python-rest-server)))
    (setf literate-python-rest-server url)
    (literate-python-request "status" :type "GET")
    (message "Connected to %s" literate-python-rest-server)))
#+END_SRC

*** send request to remote literate server
#+BEGIN_SRC elisp
(defvar literate-python-last-response nil)
(cl-defun literate-python-request (path &key params data (type "GET"))
  (setf literate-python-last-response nil)
  (awhen (get-buffer "*literate-python-error*")
    ;; Close the buffer as it will be out of date.
    (kill-buffer it))
  (let* ((request-backend 'url-retrieve)
         (server literate-python-rest-server)
         resp)
    (request (concat server "lpy/" path)
        :params params
        :parser 'json-read
        :type type
        :headers '(("Content-Type" . "application/json"))
        :sync t
        :data (encode-coding-string (json-encode data) 'utf-8 t) ; Encode and ensure unibyte
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-python-last-response response)
                     (case (request-response-status-code response)
                       (200 (setf resp (request-response-data response)))

                       (500 (user-error "Literate Python server failed:%s" response))
                       (t (user-error "Failed to request to remote Python server:%s" response))))))
    (let ((type (cdr (assoc 'type resp))))
      (cond ((equal type "error")
             (let ((stdout (cdr (assoc 'stdout resp)))
                   (stderr (cdr (assoc 'stderr resp))))
               (with-current-buffer (get-buffer-create "*literate-python-error*")
                 (erase-buffer)
                 (insert "=== Data ===\n" (encode-coding-string (json-encode data) 'utf-8 t) "\n\n")
                 (insert "==== Error ===\n" (or (cdr (assoc 'error resp)) ""))
                 (when stdout 
                   (insert "\n\n=== stdout ===\n" stdout))
                 (when stderr
                   (insert "\n\n=== stderr ===\n" (cdr (assoc 'stderr resp)))))
               (switch-to-buffer-other-window "*literate-python-error*")))))
    resp))
#+END_SRC


** Register literate modules
*** register literate modules
#+BEGIN_SRC elisp
(defun literate-python-remote-register-modules (modules)
  (literate-python-request "register" :type "POST"
                           :data modules))
#+END_SRC
*** register modules for code blocks under current point
#+BEGIN_SRC elisp
(defun literate-python-register-modules ()
  (interactive)
  (let* ((element (org-element-at-point))
         (info (second element))
         (begin (plist-get info :begin))
         (end (plist-get info :end))
         (modules (make-hash-table :test 'equal)))
    (if current-prefix-arg
      (setf end (point-max))
      (unless (eq 'headline (first element))
        (user-error "Please move point to a headline.")))
    (goto-char begin)
    (while (search-forward "#+BEGIN_SRC python" end t)
      (let* ((context-info (second (org-element-context)))
             (module-name (org-entry-get (point) "LITERATE_PYTHON_MODULE" t))
             (code (plist-get context-info :value)))
        (push code (gethash module-name modules nil))))
    (let ((modules-list (cl-loop for key being the hash-keys of modules collect
                                 `((name . ,key)
                                   ("content" . ,(mapconcat 'identity (reverse (gethash key modules)) "\n"))))))
      ;; TODO: add empty "__init__" module if not exists for a package.
      (literate-python-remote-register-modules modules-list)
      (message "Registered %s modules." (hash-table-count modules)))))
#+END_SRC

** Source Code Execution
*** customized variables for server host and port
#+BEGIN_SRC elisp
(defcustom literate-python-rest-server "http://localhost:7330/"
  "The server address for literate python server."
  :type 'string
  :group 'literate-python)

#+END_SRC
*** execute source codes in specified module for org-babel-python-evaluate
#+BEGIN_SRC elisp
(defun literate-python-setup-org-babel ()
  (setf org-babel-python--exec-tmpfile
        "\
with open('%s') as __org_babel_python_tmpfile:
    exec(compile(__org_babel_python_tmpfile.read(), __org_babel_python_tmpfile.name, 'exec'))"))
#+END_SRC
*** execute source code in remote server
#+BEGIN_SRC elisp
(cl-defun literate-python-remote-execute-code (code &key (type :exec) (module) (module-create-method "import_or_create"))
  (literate-python-request "execute" :type "POST"
                           :data `((type . ,(subseq (symbol-name type) 1))
                                   (module . ,module)
                                   (module-create-method . ,module-create-method)
                                   (code . ,code))))
#+END_SRC
*** execute source code in current code block
We have to switch back to org buffer, otherwise =org-babel-execute-src-block-maybe= will report a message and
override our own compilation report.
#+BEGIN_SRC elisp
(defun literate-python-execute-current-code-block ()
  (interactive)
  (let* ((context-info (second (org-element-context)))
         (block-arguments (third (org-babel-get-src-block-info)))
         (info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (code (plist-get context-info :value))
         (type (intern (or (org-entry-get (point) "LITERATE_PYTHON_EXECUTE_TYPE" t)
                           ":exec")))
         (module-create-method (or (org-entry-get (point) "LITERATE_PYTHON_MODULE_CREATE_METHOD" t)
                                   "import_or_create"))
         (module-name (org-entry-get (point) "LITERATE_PYTHON_MODULE" t))
         (resp (literate-python-remote-execute-code code :type type :module module-name :module-create-method module-create-method)))
    (with-current-buffer (get-buffer-create "*literate-python-stdout*")
      (awhen (cdr (assoc 'stdout resp))
        (goto-char (point-max))
        (insert "\n" it "\n")))
    (if (equal type :exec)
      (message "Executed code block in module %s" module-name)
      (let ((json-encoding-pretty-print t))
        (when (not (equal "none" (cdr (assoc :results block-arguments))))
          (org-babel-insert-result (json-encode (cdr (assoc 'result resp))) '("replace")))
        (message "Evaluated code block in module %s:\n%s" module-name (cdr (assoc 'result resp)))))))
#+END_SRC
*** get top level python code
#+BEGIN_SRC elisp
(defun literate-python-get-top-level-node-at-point ()
  "Get the current top level node at point, return a cons of start and end position."
  (let* ((node (treesit-node-at (point)))
         (parent (treesit-node-parent node)))
    (while (and parent (not (equal "module" (treesit-node-type parent))))
      (setq node parent)
      (setq parent (treesit-node-parent node)))
    node))
#+END_SRC
*** get the module name for a file name
#+BEGIN_SRC elisp
(cl-defun literate-python-module-name-from-file-name (&optional (file (buffer-file-name)))
  "Get the module name from a file name."
  (let* ((package-root (lsp-workspace-root))
         (relative-name (f-no-ext (f-relative file package-root))))
    (when (locate-dominating-file relative-name "site-packages")
      (setf relative-name (apply 'f-join (nthcdr 4 (split-string relative-name "/")))))
    (dired-replace-in-string "/" "." relative-name)))
#+END_SRC
*** load python code to current module
#+BEGIN_SRC elisp
(defun literate-python-load-code-in-current-namespace ()
  (interactive)
  (let* ((node (literate-python-get-top-level-node-at-point))
         (begin (treesit-node-start node))
         (end (treesit-node-end node))
         (code (buffer-substring-no-properties begin end))
         (file (buffer-file-name))
         (org-babel-p (equalp "org" (f-ext file)))
         (module-name (if org-babel-p
                        (org-entry-get (point) "LITERATE_PYTHON_MODULE" t)
                        (literate-python-module-name-from-file-name file)))
         (module-create-method (or (org-entry-get (point) "LITERATE_PYTHON_MODULE_CREATE_METHOD" t)
                                   "import_or_create")))
    ;; To Fix module name with syntax `...literate-python.literate_python.module_a'
    (let ((prefix-dot-count 0))
      (while (eq ?. (aref module-name prefix-dot-count))
        (incf prefix-dot-count))
      (let ((index prefix-dot-count))
        (while (> prefix-dot-count 1)
          (setf index (1+ (position ?. module-name :start index)))
          (decf prefix-dot-count))
        (when (> index 0)
          (setf module-name (substring module-name index)))))

    (literate-python-remote-execute-code code :type :exec :module module-name :module-create-method module-create-method)
    (message "Loaded %s[%s:%s] in module %s" (treesit-node-type node) begin end module-name)))
#+END_SRC
** register python modules 
* Python inspector for Emacs
** Package for python inspector
:PROPERTIES:
:LITERATE_PYTHON_MODULE: literate_python.inspector
:header-args: :tangle ./literate_python/inspector.py
:END:
**** Import required packages
#+BEGIN_SRC python
import json
from inspect import getmembers, isbuiltin, ismethod
from typing import Dict
from datetime import datetime
from multimethod import multimethod

#+END_SRC
**** Utility functions
***** stringify a variable
#+BEGIN_SRC python
def stringify_val(member):
    key, val = member
    if isinstance(val, str):
        return key, '"{}"'.format(val)
    if type(val) in (dict, tuple, list):
        return key, _inspect(val)
    return key, f"{str(val)} {str(type(val))}"

#+END_SRC
***** is trash
#+BEGIN_SRC python
def is_trash(member):
    key, val = member
    return (
        key in ["__doc__", "__class__", "__hash__", "__dict__"]
        or ismethod(val)
        or isbuiltin(val)
        or type(val).__name__ == "method-wrapper"
    )

#+END_SRC
***** Turns a non-primitive obj into a dictionary of its fields and their values.
#+BEGIN_SRC python
def _pyinspect_inspect_object(obj):
    """
    Turns a **non-primitive** obj into a dictionary of its fields and their values.
    Filters out some built-in magic fields and pretty-prints dictionary values via `json.dumps`.
    Doesn't display methods.
    """
    return dict(stringify_val(m) for m in reversed(getmembers(obj)) if not is_trash(m))

#+END_SRC
***** Surrounds string key with extra quotes
#+BEGIN_SRC python
def _pyinspect_add_quotes(key):
    """
    Surrounds string key with extra quotes because Emacs parses them as just symbols
    and makes it hard to distinguish between them and non-string symbols

    >>> _pyinspect_add_quotes("hello")
    '"hello"'

    >>> _pyinspect_add_quotes(1)
    1
    """
    return '"{}"'.format(key) if type(key) is str else key

#+END_SRC
***** trim_seq
#+BEGIN_SRC python
def trim_seq(seq, elem_cap):
    if type(seq) is dict:
        return _pyinspect_take_dict(seq, elem_cap)
    elif type(seq) in (tuple, list):
        return seq[:elem_cap]

#+END_SRC
***** Returns a new dictionary with the first n pairs from d
#+BEGIN_SRC python
def _pyinspect_take_dict(d: Dict, n: int):
    "Returns a new dictionary with the first n pairs from d"

    def iterator():
        i = 0
        for item in d.items():
            if i == n:
                break
            yield item
            i += 1

    return dict(iterator())

#+END_SRC
**** Dispatches the appropriate inspection according to obj type
***** generic method
#+BEGIN_SRC python
@multimethod
def _inspect(obj) -> dict:
    return {"type": "object", "value": _pyinspect_inspect_object(obj)}

#+END_SRC
***** str
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: str) -> dict:
    return {"type": "string", "value": obj}

#+END_SRC
***** bool
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: bool) -> dict:
    return {"type": "bool", "value": obj}

#+END_SRC
***** int
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: int) -> dict:
    return {"type": "integer", "value": obj}
#+END_SRC

***** float
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: float) -> dict:
    return {"type": "float", "value": obj}
#+END_SRC

***** complex
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: complex) -> dict:
    return {"type": "complex", "value": obj}
#+END_SRC
***** tuple
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: tuple) -> dict:
    return {
        "type": "tuple",
        "value": [_inspect(item) for item in obj],
    }

#+END_SRC

***** list
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: list) -> dict:
    return {
        "type": "list",
        "value": [_inspect(item) for item in obj],
    }

#+END_SRC

***** dict
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: dict) -> dict:
    return {
        "type": "dict",
        "value": {_pyinspect_add_quotes(k): _inspect(v) for (k, v) in obj.items()},
    }

#+END_SRC

***** datetime
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: datetime) -> dict:
    print(f"obj: {obj}")
    return {
        "type": "datetime",
        "value": obj.isoformat(),
    }

#+END_SRC

**** inspect as json
#+BEGIN_SRC python
def _pyinspect_json(obj):
    return json.dumps(_inspect(obj), indent=4, default=lambda o: _pyinspect(o)["value"])

#+END_SRC
* Sync between org files and python files
:PROPERTIES:
:literate-lang: elisp
:END:
** Introduction
Even though we can write Python code in org files, we still need to sync them with Python files,
especially when we want to share the code with others, or import code changes from others.
** Import
*** How
We try to import Python code from Python files to an org file by using Emacs's new library [[https://tree-sitter.github.io/tree-sitter/using-parsers][tree-sitter]].

We can get the node filed types in [[https://github.com/tree-sitter/tree-sitter-python/blob/master/src/node-types.json][this file]] for Python.

For example, in the following Python code block, we can parse the Python code and get the first function name.
#+BEGIN_SRC elisp :load no
(with-temp-buffer
    ;; (insert "def say_hello():\n  print('Hello')\n")
    (insert "yaml.add_representer(Canonical, dataclass_representer)\n")
  (let ((language (tree-sitter-require 'python))
        (parser (tsc-make-parser)))
    (tsc-set-language parser language)
    (let* ((str (buffer-string))
           (tree (tsc-parse-string parser str))
           (root (tsc-root-node tree))
           (first-child (tsc-get-nth-child root 0))
           (first-child-name (tsc-get-child-by-field first-child :name)))
      ;; (message "first child node type: %s, name:%s" (tsc-node-type first-child) (tsc-node-text first-child-name))
      (let ((grandchild (tsc-get-nth-child first-child 0)))
        (message "%s" (tsc-node-text (tsc-get-child-by-field grandchild :function))))
      ;; (message "%s" (tsc-tree-to-sexp tree))
      )))
#+END_SRC

*** Implementation
**** import required elisp libraries
#+BEGIN_SRC elisp
(require 'tree-sitter)
(require 'tree-sitter-langs)
(require 'f); for file operations
#+END_SRC
**** Utilities
***** how to prepare a new org section for a Python module
#+BEGIN_SRC elisp
(cl-defun literate-python-new-org-section-for-a-module (module-name new-level &key (title module-name))
  (loop repeat new-level do (insert "*"))
  (insert " " title "\n")
  (org-entry-put (point) "LITERATE_PYTHON_MODULE" module-name))
#+END_SRC
***** the parse tree for current file
#+BEGIN_SRC elisp
(defun literate-python-parse-tree-for-current-file ()
  (let ((language (tree-sitter-require 'python))
        (parser (tsc-make-parser)))
    (tsc-set-language parser language)
    (tsc-parse-string parser (buffer-string))))
#+END_SRC

***** get the comment for a module
The comment for a module is usually the first string in the Python file before any meaning code.
#+BEGIN_SRC elisp
(defun literate-python-module-comment-from-node (node)
  (when (eq 'module (tsc-node-type node)) 
    (let* ((index 0)
                (child (tsc-get-nth-child node index)))
      (while (and child
                  (eq 'comment (tsc-node-type child)))
        (incf index)
        (setq child (tsc-get-nth-child node index)))
      (when (and child
                 (eq 'expression_statement (tsc-node-type child)))
        (setf child (tsc-get-nth-child child 0))
        (when (eq 'string (tsc-node-type child))
          (tsc-node-text (tsc-get-nth-child child 1)))))))
#+END_SRC

**** How to get the name of a parse node
***** generic function
#+BEGIN_SRC elisp
(cl-defgeneric literate-python-node-name (node-type node)
  (:documentation "Get the name of a node."))
#+END_SRC
***** function definition
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql function_definition)) node)
  (format "Function %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

***** class_definition
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql class_definition)) node)
  (format "Class %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

***** decorated_definition
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql decorated_definition)) node)
  (let* ((name-list nil)
         (index 0)
         (child (tsc-get-nth-child node index)))
    (while (eq 'decorator (tsc-node-type child))
      (setf name-list (nconc name-list (list (tsc-node-text (tsc-get-nth-child child 1)))))
      (incf index)
      (setf child (tsc-get-nth-child node index)))
    (format "@%s: %s" (mapconcat 'identity name-list " ")
            (literate-python-node-name (tsc-node-type child) child))))
#+END_SRC
***** assignment
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql assignment)) node)
  (let ((code (dired-replace-in-string "\n" " " (tsc-node-text node))))
    (if (<= (length code) literate-python-max-title-size)
      (format "Assignment %s" code)
      (format "Assignment %s" (tsc-node-text (tsc-get-child-by-field node :left))))))
#+END_SRC

***** augmented_assignment
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql augmented_assignment)) node)
  (let ((code (dired-replace-in-string "\n" " " (tsc-node-text node))))
    (if (<= (length code) literate-python-max-title-size)
      (format "Assignment %s" code)
      (format "Assignment %s" (tsc-node-text (tsc-get-child-by-field node :left))))))
#+END_SRC
***** call
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql call)) node)
  (let ((call-code (dired-replace-in-string "\n" " " (tsc-node-text node))))
    (if (<= (length call-code) literate-python-max-title-size)
      (format "Call %s" call-code)
      (format "Call %s" (tsc-node-text (tsc-get-child-by-field node :function))))))
#+END_SRC

***** try
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql try_statement)) node)
  "Try statement")
#+END_SRC

***** while
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql while_statement)) node)
  "While statement")
#+END_SRC

***** the default implementation
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name (node-type node)
  (format "%s" node-type))
#+END_SRC
***** string
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql string)) node)
  "String")
#+END_SRC

***** comment
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql comment)) node)
  "Comment")
#+END_SRC

***** import
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql import)) node)
  "Import")
#+END_SRC
***** import_from_statement
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql import_from_statement)) node)
  "Import")
#+END_SRC

***** expression
#+BEGIN_SRC elisp
(cl-defmethod literate-python-node-name ((node-type (eql expression_statement)) node)
  (let ((new-node (tsc-get-nth-child node 0)))
    (literate-python-node-name (ts-node-type new-node) new-node)))
#+END_SRC

**** ignored directories
#+BEGIN_SRC elisp
(defcustom literate-python-ignored-dirs '("__pycache__" ".git" ".vscode" ".idea")
  "The directories to be ignored when importing Python packages."
  :group 'literate-python)
#+END_SRC

**** the maximum size of a title for an org section
#+BEGIN_SRC elisp
(defcustom literate-python-max-title-size 80
  "The maximum size of a title for an org section."
  :group 'literate-python)
#+END_SRC

**** iterate a directory to import Python files
#+BEGIN_SRC elisp
(cl-defun literate-python-import (&key (level (or (org-current-level) 0))
                                                      module-name module-path)
  "Import Python codes from a directory to an org file."
  (interactive "")
  (let* ((module-name (or module-name
                          (or (org-entry-get (point) "LITERATE_PYTHON_MODULE" t)
                              (org-entry-get (point) "LITERATE_PYTHON_ROOT_MODULE" t))))
         (module-path (or module-path
                          (let* ((root-path (org-entry-get (point) "LITERATE_PYTHON_ROOT_MODULE_PATH" t))
                                 (path (when root-path
                                         (concat root-path "/" (dired-replace-in-string "\\." "/" module-name)))))
                            (when path
                              (if (f-directory? path)
                                path
                                (let ((path (concat path ".py")))
                                  (if (f-exists-p path)
                                    path)))))
                          (org-entry-get (point) "LITERATE_PYTHON_MODULE_PATH" t)))
         (new-level (1+ level)))
    (if (f-directory-p module-path)
      (progn
        ;; TODO: cleanup empty directories.
        (dolist (file (directory-files module-path t "\.py$"))
          (let* ((relative-name (f-no-ext (f-relative file module-path)))
                 (new-module-name (format "%s.%s" module-name (dired-replace-in-string "/" "." relative-name))))
            (literate-python-import-python-code-to-org file new-level new-module-name)))

        (dolist (directory (f-directories module-path))
          (let* ((relative-name (f-no-ext (f-relative directory module-path)))
                 (new-module-name (format "%s.%s" module-name (dired-replace-in-string "/" "." relative-name))))
            (unless (loop for ignored-name in literate-python-ignored-dirs
                          thereis (search ignored-name new-module-name))
              (literate-python-new-org-section-for-a-module new-module-name new-level :title (or (f-ext relative-name) relative-name))
              (literate-python-import :level new-level :module-name new-module-name :module-path directory)))))
      (literate-python-import-python-code-to-org module-path level module-name :with-org-section nil))))
#+END_SRC
**** get pieces of code blocks in a python file
To investigate the parse tree, we can use Emacs command [[https://github.com/emacs-mirror/emacs/blob/master/admin/notes/tree-sitter/starter-guide#query-references][treesit-explore-mode]]
#+BEGIN_SRC elisp
(defun literate-python-get-code-blocks-in-file (file)
  (with-current-buffer (find-file-noselect file)
    (let* ((tree (literate-python-parse-tree-for-current-file))
           (root (tsc-root-node tree))
           (count-of-children (tsc-count-children root))
           (module-comment (when (> count-of-children 0)
                             (literate-python-module-comment-from-node root)))
           (current-index 0)
           (next-index 0)
           (next-title nil)
           (code-blocks nil))
      (while (< current-index count-of-children)
        (cl-multiple-value-setq (next-index next-title)
          (literate-python-next-code-block-index root current-index))
        (setf code-blocks
                (nconc code-blocks
                       (list (cons (dired-replace-in-string "\n" " " next-title)
                                   (let ((begin (tsc-node-start-position (ts-get-nth-child root current-index)))
                                         (end (tsc-node-end-position (ts-get-nth-child root next-index))))
                                     (concat (buffer-substring-no-properties begin end) "\n"))))))
        (setf current-index (1+ next-index)))
      (cons module-comment code-blocks))))
#+END_SRC

**** import a python file
#+BEGIN_SRC elisp
(defcustom literate-python-org-babel-lang "python" "The org-babel language for literate python."
  :group 'literate-python)

(cl-defun literate-python-import-python-code-to-org (file level module-name &key (with-org-section t))
  (let* ((new-level (1+ level))
           (code-blocks-info (literate-python-get-code-blocks-in-file file))
         (module-comment (car code-blocks-info))
         (module-title (when module-comment
                        (first (split-string module-comment "\n" t nil))))
         (code-blocks (cdr code-blocks-info)))
    (when with-org-section
      (literate-python-new-org-section-for-a-module module-name level :title (or module-title (f-ext module-name) module-name))
      (let* ((module-root-path (org-entry-get (point) "LITERATE_PYTHON_ROOT_MODULE_PATH" t))
             (root-module (org-entry-get (point) "LITERATE_PYTHON_ROOT_MODULE" t))
             (module-file-name (dired-replace-in-string "\\." "/" (if root-module
                                                                    (subseq module-name (length root-module))
                                                                    module-name))))
        (when (and (> (length module-root-path) 0)
                   (not (string-suffix-p "/" module-root-path)))
          (setf module-root-path (concat module-root-path "/")))
        (org-entry-put (point) "header-args" (format ":tangle %s%s.py" module-root-path module-file-name))))

    (loop for (title . code) in code-blocks do
      (loop repeat new-level do (insert "*"))
      (insert " " title "\n")
      (insert "#+BEGIN_SRC " literate-python-org-babel-lang "\n")
      (insert code)
      (insert "\n#+END_SRC\n"))))
#+END_SRC
**** get the next code block index
#+BEGIN_SRC elisp
(cl-defun literate-python-next-code-block-index (root start-index)
  (let* ((max-index (1- (tsc-count-children root)))
         (current-index start-index)
         (current-node nil)
         (current-node-type nil)
         (next-index nil)
         (next-node-type nil)
         (next-node nil)
         (next-title nil)
         (collected-valid-node-types nil)
         (previous-node nil)
         (previous-node-type nil))
    (while (<= current-index max-index)
      (setf previous-node current-node)
      (setf previous-node-type current-node-type)
      (setf current-node (ts-get-nth-child root current-index))
      (setf current-node-type (ts-node-type current-node))
      (unless (eq 'comment current-node-type)
        (push current-node-type collected-valid-node-types))

      (when (= current-index max-index)
        (return-from literate-python-next-code-block-index (values max-index (literate-python-node-name current-node-type current-node))))
      (setf next-index (1+ current-index)
            next-node (ts-get-nth-child root next-index)
            next-node-type (ts-node-type next-node))
      (cl-case current-node-type 
        (comment 
         (if (and previous-node-type
                  (not (find previous-node-type '(comment)) )
                  (find (first collected-valid-node-types) '(import_statement import_from_statement))
                  (not (find next-node-type '(import_statement import_from_statement comment))))
           (return-from literate-python-next-code-block-index (values (1- current-index) (literate-python-node-name previous-node-type previous-node)))
           (incf current-index)))
        ((import_statement import_from_statement)
         (cond ((find next-node-type '(import_statement import_from_statement comment))
                (incf current-index))
               (t
                (return-from literate-python-next-code-block-index (values current-index "Import statements")))))
        (decorated_definition
         (return-from literate-python-next-code-block-index
           (values current-index (literate-python-node-name current-node-type current-node))))
        (class_definition
         (return-from literate-python-next-code-block-index
           (values current-index (literate-python-node-name current-node-type current-node))))
        (function_definition
         (return-from literate-python-next-code-block-index
           (values current-index (literate-python-node-name current-node-type current-node))))
        (expression_statement
         (let* ((first-child-node (ts-get-nth-child current-node 0))
                (first-child-node-type (ts-node-type first-child-node)))
           (cl-case first-child-node-type
             (comment
              (incf next-index)
              (setf next-node (ts-get-nth-child root next-index))
              (setf next-node-type (ts-node-type next-node)))
             (string
              (return-from literate-python-next-code-block-index (values current-index "Docstring")))
             (assignment
              ;; if there is a docstring for this assignment, continue to next index
              (if (and (eq 'expression_statement next-node-type)
                       (eq 'string (ts-node-type (ts-get-nth-child next-node 0))))
                (incf current-index)
                (return-from literate-python-next-code-block-index
                  (values current-index
                          (literate-python-node-name first-child-node-type first-child-node)))))
             (t
              (return-from literate-python-next-code-block-index
                (values current-index
                        (literate-python-node-name first-child-node-type first-child-node)))))))
        (t
         (incf current-index))))))
#+END_SRC

** Export
* Run python code in specified module
:PROPERTIES:
:literate-lang: elisp
:END:
** setup current module in python REPL
*** a special variable for current module name in python REPL
#+BEGIN_SRC elisp
(defvar literate-python-current-module nil
        "The current python module name to be used when execute a code.")
#+END_SRC
*** display namespace in the mode line in buffer for python REPL 
#+BEGIN_SRC elisp
(defun literate-python-current-namespace-in-repl ()
  `(
    "/"
    ,(or literate-python-current-module "*")
    "/"))
(add-to-list 'mode-line-misc-info
             `(inferior-python-mode (" [" literate-python-current-namespace-in-repl "] ")))
#+END_SRC
*** a comint input sender to exec code in a namespace.
#+BEGIN_SRC elisp
(defun literate-python-comint-input-sender (proc string)
  (with-current-buffer (process-buffer proc)
    (if (eq major-mode 'inferior-python-mode)
      (let ((new-string (format "__PYTHON_EL_eval(%s, %s)\n"
                                (python-shell--encode-string string)
                                (python-shell--encode-string (or (buffer-file-name)
                                                                 "<string>")))))
        (comint-simple-send proc new-string))
      (comint-simple-send proc string))))
#+END_SRC

** setup python shell eval setup code
#+BEGIN_SRC elisp
(defun literate-python-setup-shell-eval-setup-code ()
  (setf comint-input-sender (function literate-python-comint-input-sender))
  (setf python-shell-eval-setup-code
  "\
def __PYTHON_EL_eval(source, filename, module=None):
    import ast, sys
    import os
    if sys.version_info[0] == 2:
        from __builtin__ import compile, eval, globals
    else:
        from builtins import compile, eval, globals
    try:
        p, e = ast.parse(source, filename), None
    except SyntaxError:
        t, v, tb = sys.exc_info()
        sys.excepthook(t, v, tb.tb_next)
        return
    if p.body and isinstance(p.body[-1], ast.Expr):
        e = p.body.pop()
    try:
        g = globals()
        if module is None and 'python_repl_module_name' in globals():
           module = globals()['python_repl_module_name']
        if module is not None:
           g = sys.modules[module].__dict__
        exec(compile(p, filename, 'exec'), g, g)
        if e:
            return eval(compile(ast.Expression(e.value), filename, 'eval'), g, g)
    except Exception:
        t, v, tb = sys.exc_info()
        sys.excepthook(t, v, tb.tb_next)")
  )
#+END_SRC
* Tips
:PROPERTIES:
:header-args: :tangle no
:END:
** how to start django server in REPL
#+BEGIN_SRC python
import os
import django
from django.core.management import call_command
from threading import Thread

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
django.setup()

# Function to start the server
def start_server():
    call_command('runserver', '127.0.0.1:8000', '--noreload')

# Start the server in a new thread
server_thread = Thread(target=start_server)
server_thread.start()

print("Django server started on http://127.0.0.1:8000")
#+END_SRC
* TODO[0/1]
- [ ] After reloading a definition in a code block, all modules that depend on the module to which this definition belongs are automatically reloaded.
* References
- [[https://peps.python.org/pep-0302/][PEP 302 -- New Import Hooks]]
- [[https://nbdev.fast.ai/tutorials/tutorial.html][nbdev]] (Create delightful software with Jupyter Notebooks)
  - [[https://hallmx.github.io/nbd_colab/][nbd_colab]]
- [[https://emacs-tree-sitter.github.io/api/inspecting/][tree-sitter]]
