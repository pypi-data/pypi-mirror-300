{"version":3,"file":"3c75cd1211b58b3cec95.chunk.js","mappings":"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","sources":["webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/roundDecimal.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/geo.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/luminanceFromRGB.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/MapBox.jsx"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport default function roundDecimal(number, precision) {\n  let roundedNumber;\n  let p = precision;\n  if (precision) {\n    roundedNumber = Math.round(number * (p = 10 ** p)) / p;\n  } else {\n    roundedNumber = Math.round(number);\n  }\n\n  return roundedNumber;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport roundDecimal from './roundDecimal';\n\nexport const EARTH_CIRCUMFERENCE_KM = 40075.16;\nexport const MILES_PER_KM = 1.60934;\n\nexport function kmToPixels(kilometers, latitude, zoomLevel) {\n  // Algorithm from: http://wiki.openstreetmap.org/wiki/Zoom_levels\n  const latitudeRad = latitude * (Math.PI / 180);\n  // Seems like the zoomLevel is off by one\n  const kmPerPixel =\n    (EARTH_CIRCUMFERENCE_KM * Math.cos(latitudeRad)) / 2 ** (zoomLevel + 9);\n\n  return roundDecimal(kilometers / kmPerPixel, 2);\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const LUMINANCE_RED_WEIGHT = 0.2126;\nexport const LUMINANCE_GREEN_WEIGHT = 0.7152;\nexport const LUMINANCE_BLUE_WEIGHT = 0.0722;\n\nexport default function luminanceFromRGB(r, g, b) {\n  // Formula: https://en.wikipedia.org/wiki/Relative_luminance\n  return (\n    LUMINANCE_RED_WEIGHT * r +\n    LUMINANCE_GREEN_WEIGHT * g +\n    LUMINANCE_BLUE_WEIGHT * b\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n"],"names":["roundDecimal","number","precision","roundedNumber","p","Math","round","kmToPixels","kilometers","latitude","zoomLevel","latitudeRad","PI","cos","propTypes","aggregation","PropTypes","compositeOperation","dotRadius","lngLatAccessor","locations","isRequired","pointRadiusUnit","renderWhileDragging","rgb","zoom","ScatterPlotGlowOverlay","React","constructor","props","super","this","redraw","bind","drawText","ctx","pixel","options","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","_ref","height","isDragging","project","clusterLabelMap","forEach","location","i","properties","cluster","computeClusterLabel","count","point_count","sum","mean","squaredSum","variance","sqrt","maxLabel","max","filter","v","Number","isNaN","clearRect","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointLabel","pointRadius","pointLatitude","undefined","render","___EmotionJSX","CanvasOverlay","defaultProps","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","aggregatorName","clusterer","globalOpacity","hasCustomMetric","mapStyle","mapboxApiKey","onViewportChange","bounds","NOOP","MapBox","mercator","ViewportMercator","fitBounds","longitude","state","viewport","handleViewportChange","setState","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","MapGL","_extends","mapboxApiAccessToken","preserveDrawingBuffer","coordinates","geometry"],"sourceRoot":""}