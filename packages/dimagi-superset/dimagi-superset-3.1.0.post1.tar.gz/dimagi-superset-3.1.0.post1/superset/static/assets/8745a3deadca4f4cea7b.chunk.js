"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[802],{70802:(t,e,o)=>{o.r(e),o.d(e,{default:()=>Pt,getLayer:()=>Wt});var s=o(4942),i=o(5259),n=o(37832),r=o(13717),a=o(33321),c=o(39769),l=o(53982);const g={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class u extends i.Z{getBounds(){var t;return null===(t=this.getAttributeManager())||void 0===t?void 0:t.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[n.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null===(e=this.state.model)||void 0===e||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{widthUnits:o,widthScale:s,widthMinPixels:i,widthMaxPixels:n,wrapLongitude:r}=this.props;this.state.model.setUniforms(e).setUniforms({widthUnits:a.iI[o],widthScale:s,widthMinPixels:i,widthMaxPixels:n,useShortestPath:r?1:0}).draw(),r&&this.state.model.setUniforms({useShortestPath:-1}).draw()}_getModel(t){return new c.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:5,attributes:{positions:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}),isInstanced:!0})}}(0,s.Z)(u,"layerName","LineLayer"),(0,s.Z)(u,"defaultProps",g);var d=o(91567),h=o(41576);const p=.5,S=1/6,f={N:[0,p],E:[p,0],S:[0,-.5],W:[-.5,0],NE:[p,p],NW:[-.5,p],SE:[p,-.5],SW:[-.5,-.5]},_=[f.W,f.SW,f.S],m=[f.S,f.SE,f.E],w=[f.E,f.NE,f.N],v=[f.NW,f.W,f.N],y=[[-.5,S],[-.5,-S],[-S,-.5],[S,-.5]],E=[[-S,-.5],[S,-.5],[p,-S],[p,S]],N=[[p,-S],[p,S],[S,p],[-S,p]],W=[[-.5,S],[-.5,-S],[S,p],[-S,p]],P=[f.W,f.SW,f.SE,f.E],x=[f.S,f.SE,f.NE,f.N],b=[f.NW,f.W,f.E,f.NE],A=[f.NW,f.SW,f.S,f.N],C=[[-.5,S],[-.5,-S],[p,-S],[p,S]],z=[[-S,-.5],[S,-.5],[S,p],[-S,p]],L=[f.NW,f.SW,f.SE,f.NE],D=[f.NW,f.SW,f.SE,f.E,f.N],O=[f.W,f.SW,f.SE,f.NE,f.N],I=[f.NW,f.W,f.S,f.SE,f.NE],M=[f.NW,f.SW,f.S,f.E,f.NE],T=[f.NW,f.W,[p,-S],[p,S],f.N],Z=[[-S,-.5],[S,-.5],f.E,f.NE,f.N],R=[[-.5,S],[-.5,-S],f.S,f.SE,f.E],U=[f.W,f.SW,f.S,[S,p],[-S,p]],k=[f.NW,f.W,[-S,-.5],[S,-.5],f.N],F=[[-.5,S],[-.5,-S],f.E,f.NE,f.N],B=[f.S,f.SE,f.E,[S,p],[-S,p]],j=[f.W,f.SW,f.S,[p,-S],[p,S]],G=[f.W,f.SW,f.SE,f.E,[S,p],[-S,p]],V=[[-.5,S],[-.5,-S],f.S,f.SE,f.NE,f.N],K=[f.NW,f.W,[-S,-.5],[S,-.5],f.E,f.NE],$=[f.NW,f.SW,f.S,[p,-S],[p,S],f.N],H=[f.W,f.SW,f.S,f.E,f.NE,f.N],Q=[f.NW,f.W,f.S,f.SE,f.E,f.N],X=[[-.5,S],[-.5,-S],[-S,-.5],[S,-.5],f.E,f.NE,f.N],q=[f.W,f.SW,f.S,[p,-S],[p,S],[S,p],[-S,p]],J=[f.NW,f.W,[-S,-.5],[S,-.5],[p,-S],[p,S],f.N],Y=[[-.5,S],[-.5,-S],f.S,f.SE,f.E,[S,p],[-S,p]],tt=[[-.5,S],[-.5,-S],[-S,-.5],[S,-.5],[p,-S],[p,S],[S,p],[-S,p]],et={0:[],1:[[f.W,f.S]],2:[[f.S,f.E]],3:[[f.W,f.E]],4:[[f.N,f.E]],5:{0:[[f.W,f.S],[f.N,f.E]],1:[[f.W,f.N],[f.S,f.E]]},6:[[f.N,f.S]],7:[[f.W,f.N]],8:[[f.W,f.N]],9:[[f.N,f.S]],10:{0:[[f.W,f.N],[f.S,f.E]],1:[[f.W,f.S],[f.N,f.E]]},11:[[f.N,f.E]],12:[[f.W,f.E]],13:[[f.S,f.E]],14:[[f.W,f.S]],15:[]};function ot(t){return parseInt(t,4)}const st={[ot("0000")]:[],[ot("2222")]:[],[ot("2221")]:[_],[ot("2212")]:[m],[ot("2122")]:[w],[ot("1222")]:[v],[ot("0001")]:[_],[ot("0010")]:[m],[ot("0100")]:[w],[ot("1000")]:[v],[ot("2220")]:[y],[ot("2202")]:[E],[ot("2022")]:[N],[ot("0222")]:[W],[ot("0002")]:[y],[ot("0020")]:[E],[ot("0200")]:[N],[ot("2000")]:[W],[ot("0011")]:[P],[ot("0110")]:[x],[ot("1100")]:[b],[ot("1001")]:[A],[ot("2211")]:[P],[ot("2112")]:[x],[ot("1122")]:[b],[ot("1221")]:[A],[ot("2200")]:[C],[ot("2002")]:[z],[ot("0022")]:[C],[ot("0220")]:[z],[ot("1111")]:[L],[ot("1211")]:[D],[ot("2111")]:[O],[ot("1112")]:[I],[ot("1121")]:[M],[ot("1011")]:[D],[ot("0111")]:[O],[ot("1110")]:[I],[ot("1101")]:[M],[ot("1200")]:[T],[ot("0120")]:[Z],[ot("0012")]:[R],[ot("2001")]:[U],[ot("1022")]:[T],[ot("2102")]:[Z],[ot("2210")]:[R],[ot("0221")]:[U],[ot("1002")]:[k],[ot("2100")]:[F],[ot("0210")]:[B],[ot("0021")]:[j],[ot("1220")]:[k],[ot("0122")]:[F],[ot("2012")]:[B],[ot("2201")]:[j],[ot("0211")]:[G],[ot("2110")]:[V],[ot("1102")]:[K],[ot("1021")]:[$],[ot("2011")]:[G],[ot("0112")]:[V],[ot("1120")]:[K],[ot("1201")]:[$],[ot("2101")]:[H],[ot("0121")]:[H],[ot("1012")]:[Q],[ot("1210")]:[Q],[ot("0101")]:{0:[_,w],1:[H],2:[H]},[ot("1010")]:{0:[v,m],1:[Q],2:[Q]},[ot("2121")]:{0:[H],1:[H],2:[_,w]},[ot("1212")]:{0:[Q],1:[Q],2:[v,m]},[ot("2120")]:{0:[X],1:[X],2:[y,w]},[ot("2021")]:{0:[q],1:[q],2:[_,N]},[ot("1202")]:{0:[J],1:[J],2:[v,E]},[ot("0212")]:{0:[Y],1:[Y],2:[m,W]},[ot("0102")]:{0:[y,w],1:[X],2:[X]},[ot("0201")]:{0:[_,N],1:[q],2:[q]},[ot("1020")]:{0:[v,E],1:[J],2:[J]},[ot("2010")]:{0:[m,W],1:[Y],2:[Y]},[ot("2020")]:{0:[W,E],1:[tt],2:[y,N]},[ot("0202")]:{0:[N,y],1:[tt],2:[W,E]}},it={ISO_LINES:1,ISO_BANDS:2},nt={zIndex:0,zOffset:.005};function rt(t,e){return Array.isArray(e)?t<e[0]?0:t<e[1]?1:2:t>=e?1:0}function at(t){const{cellWeights:e,x:o,y:s,width:i,height:n}=t;let r=t.threshold;t.thresholdValue&&(h.Z.deprecated("thresholdValue","threshold")(),r=t.thresholdValue);const a=o<0,c=o>=i-1,l=s<0,g=s>=n-1,u=a||c||l||g,d={},p={};a||g?p.top=0:(d.top=e[(s+1)*i+o],p.top=rt(d.top,r)),c||g?p.topRight=0:(d.topRight=e[(s+1)*i+o+1],p.topRight=rt(d.topRight,r)),c||l?p.right=0:(d.right=e[s*i+o+1],p.right=rt(d.right,r)),a||l?p.current=0:(d.current=e[s*i+o],p.current=rt(d.current,r));const{top:S,topRight:f,right:_,current:m}=p;let w=-1;Number.isFinite(r)&&(w=S<<3|f<<2|_<<1|m),Array.isArray(r)&&(w=S<<6|f<<4|_<<2|m);let v=0;return u||(v=rt((d.top+d.topRight+d.right+d.current)/4,r)),{code:w,meanCode:v}}function ct(t){const{gridOrigin:e,cellSize:o,x:s,y:i,code:n,meanCode:r,type:a=it.ISO_LINES}=t,c={...nt,...t.thresholdData};let l=a===it.ISO_BANDS?st[n]:et[n];Array.isArray(l)||(l=l[r]);const g=c.zIndex*c.zOffset,u=(s+1)*o[0],d=(i+1)*o[1],h=e[0]+u,p=e[1]+d;if(a===it.ISO_BANDS){const t=[];return l.forEach((e=>{const s=[];e.forEach((t=>{const e=h+t[0]*o[0],i=p+t[1]*o[1];s.push([e,i,g])})),t.push(s)})),t}const S=[];return l.forEach((t=>{t.forEach((t=>{const e=h+t[0]*o[0],s=p+t[1]*o[1];S.push([e,s,g])}))})),S}var lt=o(72958),gt=o(24e3),ut=o(41669),dt=o(92026);const ht=[255,255,255,255],pt="positions",St={data:{props:["cellSize"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class ft extends dt.Z{initializeState(){super.initializeAggregationLayer({dimensions:St}),this.setState({contourData:{},projectPoints:!1,weights:{count:{size:1,operation:gt.KM.SUM}}}),this.getAttributeManager().add({[pt]:{size:3,accessor:"getPosition",type:5130,fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}updateState(t){super.updateState(t);let e=!1;const{oldProps:o,props:s}=t,{aggregationDirty:i}=this.state;o.contours===s.contours&&o.zOffset===s.zOffset||(e=!0,this._updateThresholdData(t.props)),this.getNumInstances()>0&&(i||e)&&this._generateContours()}renderLayers(){const{contourSegments:t,contourPolygons:e}=this.state.contourData,o=this.getSubLayerClass("lines",u),s=this.getSubLayerClass("bands",d.Z);return[t&&t.length>0&&new o(this.getSubLayerProps({id:"lines"}),{data:this.state.contourData.contourSegments,getSourcePosition:t=>t.start,getTargetPosition:t=>t.end,getColor:t=>t.contour.color||ht,getWidth:t=>t.contour.strokeWidth||1}),e&&e.length>0&&new s(this.getSubLayerProps({id:"bands"}),{data:this.state.contourData.contourPolygons,getPolygon:t=>t.vertices,getFillColor:t=>t.contour.color||ht})]}updateAggregationState(t){const{props:e,oldProps:o}=t,{cellSize:s,coordinateSystem:i}=e,{viewport:n}=this.context,r=o.cellSize!==s;let a=e.gpuAggregation;this.state.gpuAggregation!==e.gpuAggregation&&a&&!lt.Z.isSupported(this.context.gl)&&(h.Z.warn("GPU Grid Aggregation not supported, falling back to CPU")(),a=!1);const c=a!==this.state.gpuAggregation;this.setState({gpuAggregation:a});const{dimensions:l}=this.state,g=this.isAttributeChanged(pt),{data:u,weights:d}=l;let{boundingBox:p}=this.state;if(g&&(p=(0,ut.A5)(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:p})),g||r){const{gridOffset:t,translation:e,width:o,height:r,numCol:a,numRow:c}=(0,ut.PQ)(p,s,n,i);this.allocateResources(c,a),this.setState({gridOffset:t,boundingBox:p,translation:e,posOffset:e.slice(),gridOrigin:[-1*e[0],-1*e[1]],width:o,height:r,numCol:a,numRow:c})}const S=g||c||this.isAggregationDirty(t,{dimension:u,compareAll:a}),f=this.isAggregationDirty(t,{dimension:d});f&&this._updateAccessors(t),(S||f)&&this._resetResults(),this.setState({aggregationDataDirty:S,aggregationWeightsDirty:f})}_updateAccessors(t){const{getWeight:e,aggregation:o,data:s}=t.props,{count:i}=this.state.weights;i&&(i.getWeight=e,i.operation=gt.KM[o]),this.setState({getValue:(0,gt._D)(o,e,{data:s})})}_resetResults(){const{count:t}=this.state.weights;t&&(t.aggregationData=null)}_generateContours(){const{numCol:t,numRow:e,gridOrigin:o,gridOffset:s,thresholdData:i}=this.state,{count:n}=this.state.weights;let{aggregationData:r}=n;r||(r=n.aggregationBuffer.getData(),n.aggregationData=r);const{cellWeights:a}=lt.Z.getCellData({countsData:r}),c=function(t){let{thresholdData:e,cellWeights:o,gridSize:s,gridOrigin:i,cellSize:n}=t;const r=[],a=[],c=s[0],l=s[1];let g=0,u=0;for(const t of e){const{contour:e}=t,{threshold:s}=e;for(let d=-1;d<c;d++)for(let h=-1;h<l;h++){const{code:p,meanCode:S}=at({cellWeights:o,threshold:s,x:d,y:h,width:c,height:l}),f={type:it.ISO_BANDS,gridOrigin:i,cellSize:n,x:d,y:h,width:c,height:l,code:p,meanCode:S,thresholdData:t};if(Array.isArray(s)){f.type=it.ISO_BANDS;const t=ct(f);for(const o of t)a[u++]={vertices:o,contour:e}}else{f.type=it.ISO_LINES;const t=ct(f);for(let o=0;o<t.length;o+=2)r[g++]={start:t[o],end:t[o+1],contour:e}}}}return{contourSegments:r,contourPolygons:a}}({thresholdData:i,cellWeights:a,gridSize:[t,e],gridOrigin:o,cellSize:[s.xOffset,s.yOffset]});this.setState({contourData:c})}_updateThresholdData(t){const{contours:e,zOffset:o}=t,s=e.length,i=new Array(s);for(let t=0;t<s;t++){const s=e[t];i[t]={contour:s,zIndex:s.zIndex||t,zOffset:o}}this.setState({thresholdData:i})}}(0,s.Z)(ft,"layerName","ContourLayer"),(0,s.Z)(ft,"defaultProps",{cellSize:{type:"number",min:1,max:1e3,value:1e3},getPosition:{type:"accessor",value:t=>t.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM",contours:{type:"object",value:[{threshold:1}],optional:!0,compare:3},zOffset:.005}),o(67294);var _t=o(61988),mt=o(58371),wt=o(63241),vt=o(89691),yt=o(51805),Et=o(11965);function Nt(t){var e,o;return(0,Et.tZ)("div",{className:"deckgl-tooltip"},(0,Et.tZ)(yt.Z,{label:(0,_t.t)("Centroid (Longitude and Latitude): "),value:`(${null==t?void 0:t.coordinate[0]}, ${null==t?void 0:t.coordinate[1]})`}),(0,Et.tZ)(yt.Z,{label:(0,_t.t)("Threshold: "),value:`${null==t||null==(e=t.object)||null==(o=e.contour)?void 0:o.threshold}`}))}const Wt=function(t,e,o,s){const i=t,{aggregation:n="SUM",js_data_mutator:r,contours:a,cellSize:c="200"}=i;let l=e.data.features;const g=null==a?void 0:a.map((t=>{const{lowerThreshold:e,upperThreshold:o,color:s,strokeWidth:i}=t;return o?{threshold:[e,o],color:[s.r,s.g,s.b]}:{threshold:e,color:[s.r,s.g,s.b],strokeWidth:i}}));return r&&(l=(0,wt.Z)(i.js_data_mutator)(l)),new ft({id:`contourLayer-${i.slice_id}`,data:l,contours:g,cellSize:Number(c||"200"),aggregation:n.toUpperCase(),getPosition:t=>t.position,getWeight:t=>t.weight||0,...(0,mt.N)(i,s,Nt)})},Pt=(0,vt.G)(Wt,(function(t){return t.map((t=>t.position))}))}}]);
//# sourceMappingURL=8745a3deadca4f4cea7b.chunk.js.map