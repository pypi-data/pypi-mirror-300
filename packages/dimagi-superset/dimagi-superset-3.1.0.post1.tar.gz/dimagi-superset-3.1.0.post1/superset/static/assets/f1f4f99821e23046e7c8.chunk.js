"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1609],{71609:(e,t,o)=>{o.r(t),o.d(t,{default:()=>C});var a=o(18446),n=o.n(a),i=o(67294),r=o(31069),s=o(85716),l=o(34634),c=o(54998),u=o.n(c);function g(e,t,o,a){if(void 0===o&&(o=!0),void 0===a&&(a={}),!e.datasource)return;const n=new(u())("/"),i=function(e){void 0===e&&(e="base");let t="/explore/";return["json","csv","query","results","samples"].includes(e)&&(t="/superset/explore_json/"),t}(t),r=n.search(!0);Object.keys(a).forEach((e=>{r[e]=a[e]})),r.form_data=function(e){const t=new Set;return JSON.stringify(e,((e,o)=>{if("object"==typeof o&&null!==o){if(t.has(o))try{return JSON.parse(JSON.stringify(o))}catch(e){return}t.add(o)}return o}))}(e),"standalone"===t&&(r.standalone="true");const s=n.directory(i).search(r).toString();return!o&&s.length>8e3?g({datasource:e.datasource,viz_type:e.viz_type},t,!1,{URL_IS_TOO_LONG_TO_SHARE:null}):s}var d=o(72502),p=o(42932),h=o(97874),m=o(58125),f=o(61778),v=o(1262),x=o(9503),_=o(61563);const y={deck_grid:d.getLayer,deck_screengrid:p.getLayer,deck_path:h.getLayer,deck_hex:m.getLayer,deck_scatter:f.getLayer,deck_geojson:v.getLayer,deck_arc:x.getLayer,deck_polygon:_.getLayer};var S=o(11965);const b=e=>{const t=(0,i.useRef)(),[o,a]=(0,i.useState)(),[c,u]=(0,i.useState)({}),d=(0,i.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),p=(0,i.useCallback)(((t,o,n)=>{a(n),u({}),o.data.slices.forEach((o=>{const a=[...o.form_data.filters||[],...t.filters||[],...t.extra_filters||[]],n={...o,form_data:{...o.form_data,filters:a}},i=g(n.form_data,"json");i&&r.Z.get({endpoint:i}).then((t=>{let{json:o}=t;const a=y[n.form_data.viz_type](n.form_data,o,e.onAddFilter,d,e.datasource,[],e.onSelect);u((e=>({...e,[n.slice_id]:a})))})).catch((()=>{}))}))}),[e.datasource,e.onAddFilter,e.onSelect,d]),h=(0,s.D)(e.formData.deck_slices);(0,i.useEffect)((()=>{const{formData:t,payload:o}=e;!n()(h,t.deck_slices)&&p(t,o)}),[p,h,e]);const{payload:m,formData:f,setControlValue:v,height:x,width:_}=e,b=Object.values(c);return(0,S.tZ)(l.F,{ref:t,mapboxApiAccessToken:m.data.mapboxApiKey,viewport:o||e.viewport,layers:b,mapStyle:f.mapbox_style,setControlValue:v,onViewportChange:a,height:x,width:_})},C=(0,i.memo)(b)},9503:(e,t,o)=>{o.r(t),o.d(t,{default:()=>_,getLayer:()=>x});var a=o(4942),n=o(5259),i=o(37832),r=o(13717),s=o(33321),l=o(39769),c=o(53982);const u=[0,0,0,255],g={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:u},getTargetColor:{type:"accessor",value:u},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class d extends n.Z{constructor(){super(...arguments),(0,a.Z)(this,"state",void 0)}getBounds(){var e;return null===(e=this.getAttributeManager())||void 0===e?void 0:e.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[i.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:u},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:u},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw(e){let{uniforms:t}=e;const{widthUnits:o,widthScale:a,widthMinPixels:n,widthMaxPixels:i,greatCircle:r,wrapLongitude:l}=this.props;this.state.model.setUniforms(t).setUniforms({greatCircle:r,widthUnits:s.iI[o],widthScale:a,widthMinPixels:n,widthMaxPixels:i,useShortestPath:l}).draw()}_getModel(e){let t=[];for(let e=0;e<50;e++)t=t.concat([e,1,0,e,-1,0]);const o=new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0});return o.setUniforms({numSegments:50}),o}}(0,a.Z)(d,"layerName","ArcLayer"),(0,a.Z)(d,"defaultProps",g),o(67294);var p=o(61988),h=o(58371),m=o(89691),f=o(51805),v=o(11965);function x(e,t,o,a){const n=t.data.features,i=e.color_picker,r=e.target_color_picker;return new d({data:n,getSourceColor:e=>e.sourceColor||e.color||[i.r,i.g,i.b,255*i.a],getTargetColor:e=>e.targetColor||e.color||[r.r,r.g,r.b,255*r.a],id:`path-layer-${e.slice_id}`,strokeWidth:e.stroke_width?e.stroke_width:3,...(0,h.N)(e,a,(s=e,e=>(0,v.tZ)("div",{className:"deckgl-tooltip"},(0,v.tZ)(f.Z,{label:(0,p.t)("Start (Longitude, Latitude): "),value:`${e.object.sourcePosition[0]}, ${e.object.sourcePosition[1]}`}),(0,v.tZ)(f.Z,{label:(0,p.t)("End (Longitude, Latitude): "),value:`${e.object.targetPosition[0]}, ${e.object.targetPosition[1]}`}),s.dimension&&(0,v.tZ)(f.Z,{label:`${s.dimension}: `,value:`${e.object.cat_color}`}))))});var s}const _=(0,m.B)(x,(function(e){const t=[];return e.forEach((e=>{t.push(e.sourcePosition),t.push(e.targetPosition)})),t}))},1262:(e,t,o)=>{o.r(t),o.d(t,{default:()=>C,getLayer:()=>S});var a=o(67294),n=o(69588),i=o(29319),r=o.n(i),s=o(34634),l=o(89503),c=o(63241),u=o(58371),g=o(51805),d=o(40461),p=o(11965);const h={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},m=(e,t)=>{const o={};return Object.keys(e).forEach((t=>{t in h?o[h[t]]=e[t]:o[t]=e[t]})),"string"==typeof e.fillColor&&(o.fillColor=(0,l.hexToRGB)(e.fillColor)),"string"==typeof e.strokeColor&&(o.strokeColor=(0,l.hexToRGB)(e.strokeColor)),{...o,...t}};let f;const v=(e,t,o)=>{if(null!=e&&e.features&&e.features.forEach((a=>{v(a,t,e.extraProps||o)})),null!=e&&e.geometry){const a={...e,properties:m(e.properties,t)};a.extraProps||(a.extraProps=o),f.push(a)}};function x(e){return e.object.extraProps&&(0,p.tZ)("div",{className:"deckgl-tooltip"},Object.keys(e.object.extraProps).map(((t,o)=>(0,p.tZ)(g.Z,{key:`prop-${o}`,label:`${t}: `,value:`${e.object.extraProps[t]}`}))))}const _=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.fillColor},y=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.strokeColor};function S(e,t,o,a){const i=e,r=i.fill_color_picker,s=i.stroke_color_picker,l=[r.r,r.g,r.b,255*r.a],g=[s.r,s.g,s.b,255*s.a],d={};let p;return l[3]>0&&(d.fillColor=l),g[3]>0&&(d.strokeColor=g),f=[],v(t.data,d),i.js_data_mutator&&(p=(0,c.Z)(i.js_data_mutator),f=p(f)),new n.Z({id:`geojson-layer-${i.slice_id}`,data:f,extruded:i.extruded,filled:i.filled,stroked:i.stroked,getFillColor:_,getLineColor:y,getLineWidth:i.line_width||1,pointRadiusScale:i.point_radius_scale,lineWidthUnits:i.line_width_unit,...(0,u.N)(i,a,x)})}const b=e=>{var t;const o=(0,a.useRef)(),n=(0,a.useCallback)((e=>{const{current:t}=o;t&&t.setTooltip(e)}),[]),{formData:i,payload:l,setControlValue:c,onAddFilter:u,height:g,width:h}=e,m=(0,a.useMemo)((()=>{if(i.autozoom){var t,o;const a=(null==l||null==(t=l.data)||null==(o=t.features)||null==o.reduce?void 0:o.reduce(((e,t)=>{const o=r()(t);return o?[...e,[o[0],o[1]],[o[2],o[3]]]:e}),[]))||[];if(a.length)return(0,d.Z)(e.viewport,{width:h,height:g,points:a})}return e.viewport}),[i.autozoom,g,null==l||null==(t=l.data)?void 0:t.features,e.viewport,h]),f=S(i,l,0,n);return(0,p.tZ)(s.F,{ref:o,mapboxApiAccessToken:l.data.mapboxApiKey,viewport:m,layers:[f],mapStyle:i.mapbox_style,setControlValue:c,height:g,width:h})},C=(0,a.memo)(b)},72502:(e,t,o)=>{o.r(t),o.d(t,{default:()=>h,getLayer:()=>p});var a=o(51047),n=(o(67294),o(61988)),i=o(28062),r=o(58371),s=o(63241),l=o(89503),c=o(89691),u=o(51805),g=o(11965);function d(e){return(0,g.tZ)("div",{className:"deckgl-tooltip"},(0,g.tZ)(u.Z,{label:(0,n.t)("Longitude and Latitude")+": ",value:`${e.coordinate[0]}, ${e.coordinate[1]}`}),(0,g.tZ)(u.Z,{label:(0,n.t)("Height")+": ",value:`${e.object.elevationValue}`}))}function p(e,t,o,n){const c=e,u=i.getScale(c.color_scheme).range().map((e=>(0,l.hexToRGB)(e)));let g=t.data.features;c.js_data_mutator&&(g=(0,s.Z)(c.js_data_mutator)(g));const p=(0,r.Z)(c.js_agg_function,(e=>e.weight));return new a.Z({id:`grid-layer-${c.slice_id}`,data:g,cellSize:c.grid_size,extruded:c.extruded,colorRange:u,outline:!1,getElevationValue:p,getColorValue:p,...(0,r.N)(c,n,d)})}const h=(0,c.G)(p,(function(e){return e.map((e=>e.position))}))},58125:(e,t,o)=>{o.r(t),o.d(t,{default:()=>Z,getLayer:()=>L});var a=o(4942),n=o(41576),i=o(43444),r=o(79543),s=Math.PI/3,l=[0,s,2*s,3*s,4*s,5*s];function c(e){return e[0]}function u(e){return e[1]}var g=o(91575),d=o(11959),p=o(89033);function h(){}const m={colorDomain:null,colorRange:r.K,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:h,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:h,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(e,t){const{data:o,radius:a}=e,{viewport:i,attributes:r}=t,d=o.length?function(e,t){const{attributes:o}=t,a=o.positions.value,{size:n}=o.positions.getAccessor();let i,r=1/0,s=1/0,l=-1/0,c=-1/0;for(i=0;i<n*e.length;i+=n){const e=a[i],t=a[i+1];Number.isFinite(e)&&Number.isFinite(t)&&(r=Math.min(e,r),l=Math.max(e,l),s=Math.min(t,s),c=Math.max(t,c))}return[r,s,l,c].every(Number.isFinite)?[(r+l)/2,(s+c)/2]:null}(o,t):null,p=function(e,t,o){const{unitsPerMeter:a}=t.getDistanceScales(o);return e*a[0]}(a,i,d),h=[],{iterable:m,objectInfo:f}=(0,g.jB)(o),v=r.positions.value,{size:x}=r.positions.getAccessor();for(const e of m){f.index++;const t=f.index*x,o=[v[t],v[t+1]];Number.isFinite(o[0])&&Number.isFinite(o[1])?h.push({screenCoord:i.projectFlat(o),source:e,index:f.index}):n.Z.warn("HexagonLayer: invalid position")()}const _=function(){var e,t,o,a=0,n=0,i=1,r=1,g=c,d=u;function p(e){var a,n={},i=[],r=e.length;for(a=0;a<r;++a)if(!isNaN(l=+g.call(null,s=e[a],a,e))&&!isNaN(c=+d.call(null,s,a,e))){var s,l,c,u=Math.round(c/=o),p=Math.round(l=l/t-(1&u)/2),h=c-u;if(3*Math.abs(h)>1){var m=l-p,f=p+(l<p?-1:1)/2,v=u+(c<u?-1:1),x=l-f,_=c-v;m*m+h*h>x*x+_*_&&(p=f+(1&u?1:-1)/2,u=v)}var y=p+"-"+u,S=n[y];S?S.push(s):(i.push(S=n[y]=[s]),S.x=(p+(1&u)/2)*t,S.y=u*o)}return i}function h(e){var t=0,o=0;return l.map((function(a){var n=Math.sin(a)*e,i=-Math.cos(a)*e,r=n-t,s=i-o;return t=n,o=i,[r,s]}))}return p.hexagon=function(t){return"m"+h(null==t?e:+t).join("l")+"z"},p.centers=function(){for(var s=[],l=Math.round(n/o),c=Math.round(a/t),u=l*o;u<r+e;u+=o,++l)for(var g=c*t+(1&l)*t/2;g<i+t/2;g+=t)s.push([g,u]);return s},p.mesh=function(){var t=h(e).slice(0,4).join("l");return p.centers().map((function(e){return"M"+e+"m"+t})).join("")},p.x=function(e){return arguments.length?(g=e,p):g},p.y=function(e){return arguments.length?(d=e,p):d},p.radius=function(a){return arguments.length?(t=2*(e=+a)*Math.sin(s),o=1.5*e,p):e},p.size=function(e){return arguments.length?(a=n=0,i=+e[0],r=+e[1],p):[i-a,r-n]},p.extent=function(e){return arguments.length?(a=+e[0][0],n=+e[0][1],i=+e[1][0],r=+e[1][1],p):[[a,n],[i,r]]},p.radius(1)}().radius(p).x((e=>e.screenCoord[0])).y((e=>e.screenCoord[1]));return{hexagons:_(h).map(((e,t)=>({position:i.unprojectFlat([e.x,e.y]),points:e,index:t}))),radiusCommon:p}},getPosition:{type:"accessor",value:e=>e.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class f extends p.Z{constructor(){super(...arguments),(0,a.Z)(this,"state",void 0)}initializeState(){const e=new d.Z({getAggregator:e=>e.hexagonAggregator,getCellSize:e=>e.radius});this.state={cpuAggregator:e,aggregatorState:e.state,vertices:null},this.getAttributeManager().add({positions:{size:3,type:5130,accessor:"getPosition"}})}updateState(e){if(super.updateState(e),e.changeFlags.propsOrDataChanged){const t=this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==t.layerData){const{hexagonVertices:e}=t.layerData||{};this.setState({vertices:e&&this.convertLatLngToMeterOffset(e)})}this.setState({aggregatorState:t})}}convertLatLngToMeterOffset(e){const{viewport:t}=this.context;if(Array.isArray(e)&&6===e.length){const o=e[0],a=e[3],n=[(o[0]+a[0])/2,(o[1]+a[1])/2],i=t.projectFlat(n),{metersPerUnit:r}=t.getDistanceScales(n);return e.map((e=>{const o=t.projectFlat(e);return[(o[0]-i[0])*r[0],(o[1]-i[1])*r[1]]}))}return n.Z.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo(e){let{info:t}=e;return this.state.cpuAggregator.getPickingInfo({info:t})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:e,extruded:t,coverage:o,material:a,transitions:n}=this.props,{aggregatorState:r,vertices:s}=this.state,l=this.getSubLayerClass("hexagon-cell",i.Z),c=this._getSublayerUpdateTriggers();return new l({...s?{vertices:s,radius:1}:{radius:r.layerData.radiusCommon||1,radiusUnits:"common",angle:90},diskResolution:6,elevationScale:e,extruded:t,coverage:o,material:a,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:n&&{getFillColor:n.getColorValue||n.getColorWeight,getElevation:n.getElevationValue||n.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:c}),{data:r.layerData.data})}}(0,a.Z)(f,"layerName","HexagonLayer"),(0,a.Z)(f,"defaultProps",m),o(67294);var v=o(61988),x=o(28062),_=o(58371),y=o(63241),S=o(89503),b=o(89691),C=o(51805),P=o(11965);function w(e){return(0,P.tZ)("div",{className:"deckgl-tooltip"},(0,P.tZ)(C.Z,{label:(0,v.t)("Centroid (Longitude and Latitude): "),value:`(${e.coordinate[0]}, ${e.coordinate[1]})`}),(0,P.tZ)(C.Z,{label:(0,v.t)("Height")+": ",value:`${e.object.elevationValue}`}))}function L(e,t,o,a){const n=e,i=x.getScale(n.color_scheme).range().map((e=>(0,S.hexToRGB)(e)));let r=t.data.features;n.js_data_mutator&&(r=(0,y.Z)(n.js_data_mutator)(r));const s=(0,_.Z)(n.js_agg_function,(e=>null==e?void 0:e.weight));return new f({id:`hex-layer-${n.slice_id}`,data:r,radius:n.grid_size,extruded:n.extruded,colorRange:i,outline:!1,getElevationValue:s,getColorValue:s,...(0,_.N)(n,a,w)})}const Z=(0,b.G)(L,(function(e){return e.map((e=>e.position))}))},97874:(e,t,o)=>{o.r(t),o.d(t,{default:()=>g,getLayer:()=>u}),o(67294);var a=o(48897),n=o(58371),i=o(63241),r=o(89691),s=o(51805),l=o(11965);function c(e){return e.object.extraProps&&(0,l.tZ)("div",{className:"deckgl-tooltip"},Object.keys(e.object.extraProps).map(((t,o)=>(0,l.tZ)(s.Z,{key:`prop-${o}`,label:`${t}: `,value:`${e.object.extraProps[t]}`}))))}function u(e,t,o,r){const s=e,l=s.color_picker,u=[l.r,l.g,l.b,255*l.a];let g=t.data.features.map((e=>({...e,path:e.path,width:s.line_width,color:u})));return s.js_data_mutator&&(g=(0,i.Z)(s.js_data_mutator)(g)),new a.Z({id:`path-layer-${s.slice_id}`,getColor:e=>e.color,getPath:e=>e.path,getWidth:e=>e.width,data:g,rounded:!0,widthScale:1,widthUnits:s.line_width_unit,...(0,n.N)(s,r,c)})}const g=(0,r.G)(u,(function(e){let t=[];return e.forEach((e=>{t=t.concat(e.path)})),t}))},61563:(e,t,o)=>{o.r(t),o.d(t,{default:()=>E,getLayer:()=>j});var a=o(67294),n=o(61988),i=o(4942),r=o(36750),s=o(41576),l=o(91575),c=o(91567),u=o(48897),g=o(40245),d=o(67186);const p=[0,0,0,255],h={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:e=>e.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:p},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class m extends r.Z{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&s.Z.removed("getLineDashArray","PathStyleExtension")()}updateState(e){let{changeFlags:t}=e;const o=t.dataChanged||t.updateTriggersChanged&&(t.updateTriggersChanged.all||t.updateTriggersChanged.getPolygon);if(o&&Array.isArray(t.dataChanged)){const e=this.state.paths.slice(),o=t.dataChanged.map((t=>(0,d.b)({data:e,getIndex:e=>e.__source.index,dataRange:t,replace:this._getPaths(t)})));this.setState({paths:e,pathsDiff:o})}else o&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(e){void 0===e&&(e={});const{data:t,getPolygon:o,positionFormat:a,_normalize:n}=this.props,i=[],r="XY"===a?2:3,{startRow:s,endRow:c}=e,{iterable:u,objectInfo:d}=(0,l.jB)(t,s,c);for(const e of u){d.index++;let t=o(e,d);n&&(t=g.Fv(t,r));const{holeIndices:a}=t,s=t.positions||t;if(a)for(let t=0;t<=a.length;t++){const o=s.slice(a[t-1]||0,a[t]||s.length);i.push(this.getSubLayerRow({path:o},e,d.index))}else i.push(this.getSubLayerRow({path:s},e,d.index))}return i}renderLayers(){const{data:e,_dataDiff:t,stroked:o,filled:a,extruded:n,wireframe:i,_normalize:r,_windingOrder:s,elevationScale:l,transitions:g,positionFormat:d}=this.props,{lineWidthUnits:h,lineWidthScale:m,lineWidthMinPixels:f,lineWidthMaxPixels:v,lineJointRounded:x,lineMiterLimit:_,lineDashJustified:y}=this.props,{getFillColor:S,getLineColor:b,getLineWidth:C,getLineDashArray:P,getElevation:w,getPolygon:L,updateTriggers:Z,material:R}=this.props,{paths:A,pathsDiff:M}=this.state,D=this.getSubLayerClass("fill",c.Z),T=this.getSubLayerClass("stroke",u.Z),k=this.shouldRenderSubLayer("fill",A)&&new D({_dataDiff:t,extruded:n,elevationScale:l,filled:a,wireframe:i,_normalize:r,_windingOrder:s,getElevation:w,getFillColor:S,getLineColor:n&&i?b:p,material:R,transitions:g},this.getSubLayerProps({id:"fill",updateTriggers:Z&&{getPolygon:Z.getPolygon,getElevation:Z.getElevation,getFillColor:Z.getFillColor,lineColors:n&&i,getLineColor:Z.getLineColor}}),{data:e,positionFormat:d,getPolygon:L});return[!n&&k,!n&&o&&this.shouldRenderSubLayer("stroke",A)&&new T({_dataDiff:M&&(()=>M),widthUnits:h,widthScale:m,widthMinPixels:f,widthMaxPixels:v,jointRounded:x,miterLimit:_,dashJustified:y,_pathType:"loop",transitions:g&&{getWidth:g.getLineWidth,getColor:g.getLineColor,getPath:g.getPolygon},getColor:this.getSubLayerAccessor(b),getWidth:this.getSubLayerAccessor(C),getDashArray:this.getSubLayerAccessor(P)},this.getSubLayerProps({id:"stroke",updateTriggers:Z&&{getWidth:Z.getLineWidth,getColor:Z.getLineColor,getDashArray:Z.getLineDashArray}}),{data:A,positionFormat:d,getPath:e=>e.path}),n&&k]}}(0,i.Z)(m,"layerName","PolygonLayer"),(0,i.Z)(m,"defaultProps",h);var f=o(70325),v=o(51805),x=o(81763),_=o.n(x),y=o(4065),S=o(39828),b=o(2995),C=o(45511),P=o(89503);const w=10;function L(e,t,o){let{break_points:a,num_buckets:n}=e;if(!t)return[];if(void 0===a||0===a.length){const e=n?parseInt(n,10):w,[a,i]=(0,y.extent)(t,o).map((e=>"string"==typeof e?parseFloat(e):e));if(void 0===a||void 0===i)return[];const r=(i-a)/e,s=0===r?0:Math.max(0,Math.ceil(Math.log10(1/r))),l=i>parseFloat(i.toFixed(s))?1:0,c=a<parseFloat(a.toFixed(s))?a-1:a;return new Array(e+1+l).fill(0).map(((e,t)=>(c+t*r).toFixed(s)))}return a.sort(((e,t)=>parseFloat(e)-parseFloat(t)))}function Z(e,t,o){let{break_points:a,num_buckets:n,linear_color_scheme:i,opacity:r}=e;const s=a||n?L({break_points:a,num_buckets:n},t,o):null,l=Array.isArray(i)?new b.Z({colors:i,id:"custom"}):(0,C.Z)().get(i);if(!l)return null;let c,u;if(null!==s){const e=s.length-1,t=e>1?l.getColors(e):[l.colors[l.colors.length-1]],o=t[0],a=t[t.length-1];t.unshift(o),t.push(a);const n=s.map(parseFloat);c=(0,S.Z)().domain(n).range(t),u=t=>!!t&&(t>n[e]||t<n[0])}else{const e=(0,y.extent)(t,o);c=e.some(_())?l.createLinearScale((0,y.extent)(t,o)):l.createLinearScale(),u=()=>!1}return e=>{const t=o(e);if(!t)return[0,0,0,0];const a=(0,P.hexToRGB)(c(t));return u(t)?a[3]=0:a[3]=r/100*255,a}}var R=o(58371),A=o(63241);function M(e){return"geometry"in e.polygon?e.polygon.geometry.coordinates[0]:e.polygon}var D=o(40461),T=o(34634),k=o(11965);function j(e,t,o,a,i,r){const s=e,l=s.fill_color_picker,c=s.stroke_color_picker;let u=[...t.data.features];s.js_data_mutator&&(u=(0,A.Z)(s.js_data_mutator)(u));const g=s.metric?s.metric.label||s.metric:null,d=null===s.metric?()=>[l.r,l.g,l.b,255*l.a]:Z(s,u,(e=>e[g])),p=e=>{const t=(null==d?void 0:d(e))||[0,0,0,0];return i.length>0&&!i.includes(e[s.line_column])&&(t[3]/=2),t},h=s.line_column&&s.metric&&["json","geohash","zipcode"].includes(s.line_type)?function(e){return t=>{const o=e.metric.label||e.metric;return(0,k.tZ)("div",{className:"deckgl-tooltip"},t.object.name&&(0,k.tZ)(v.Z,{label:(0,n.t)("name")+": ",value:`${t.object.name}`}),t.object[e.line_column]&&(0,k.tZ)(v.Z,{label:`${e.line_column}: `,value:`${t.object[e.line_column]}`}),e.metric&&(0,k.tZ)(v.Z,{label:`${o}: `,value:`${t.object[o]}`}))}}(s):()=>null;return new m({id:`path-layer-${s.slice_id}`,data:u,filled:s.filled,stroked:s.stroked,getPolygon:M,getFillColor:p,getLineColor:[c.r,c.g,c.b,255*c.a],getLineWidth:s.line_width,extruded:s.extruded,lineWidthUnits:s.line_width_unit,getElevation:e=>function(e,t){return 0===t(e)[3]?0:e.elevation}(e,p),elevationScale:s.multiplier,fp64:!0,...(0,R.N)(s,a,h,r)})}const z=e=>{const t=(0,a.useRef)(),o=(0,a.useCallback)((()=>{let t={...e.viewport};if(e.formData.autozoom){const o=e.payload.data.features||[];t=(0,D.Z)(t,{width:e.width,height:e.height,points:o.flatMap(M)})}return t.zoom<0&&(t.zoom=0),t}),[e]),[n,i]=(0,a.useState)(0),[r,s]=(0,a.useState)(o()),[l,c]=(0,a.useState)(e.payload.form_data),[u,g]=(0,a.useState)([]);(0,a.useEffect)((()=>{const{payload:t}=e;t.form_data!==l&&(s(o()),g([]),i(0),c(t.form_data))}),[o,e,l,r]);const d=(0,a.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),p=(0,a.useCallback)((t=>{const{formData:o,onAddFilter:a}=e,r=(new Date).getDate(),s=r-n<=250,l=[...u];if(s)l.splice(0,l.length,t);else if(o.toggle_polygons){const e=l.indexOf(t);-1===e?l.push(t):l.splice(e,1)}else l.splice(0,1,t);g(l),i(r),o.table_filter&&a(o.line_column,u,!1,!0)}),[n,e,u]),h=(0,a.useCallback)((()=>void 0===e.payload.data.features?[]:[j(e.formData,e.payload,e.onAddFilter,d,u,p)]),[p,e.formData,e.onAddFilter,e.payload,u,d]),{payload:m,formData:v,setControlValue:x}=e,_=v.metric?v.metric.label||v.metric:null,y=function(e,t,o){const a=L(e,t,o),n=Z(e,t,o),i={};return a.slice(1).forEach(((t,o)=>{const r=`${a[o]} - ${a[o+1]}`,s=.5*(parseFloat(a[o])+parseFloat(a[o+1])),l=e.metric?e.metric.label||e.metric:null;i[r]={color:null==n?void 0:n({[l||e.metric]:s}),enabled:!0}})),i}(v,m.data.features,(e=>e[_]));return(0,k.tZ)("div",{style:{position:"relative"}},(0,k.tZ)(T.F,{ref:t,viewport:r,layers:h(),setControlValue:x,mapStyle:v.mapbox_style,mapboxApiAccessToken:m.data.mapboxApiKey,width:e.width,height:e.height}),null!==v.metric&&(0,k.tZ)(f.Z,{categories:y,position:v.legend_position,format:v.legend_format}))},E=(0,a.memo)(z)},61778:(e,t,o)=>{o.r(t),o.d(t,{default:()=>p,getLayer:()=>d});var a=o(73715),n=(o(67294),o(56652)),i=o(61988),r=o(58371),s=o(89691),l=o(51805);const c=1609.34;var u=o(11965);function g(e,t){return o=>{var a;const r=(null==t?void 0:t[e.point_radius_fixed.value])||(0,n.Z)(null==(a=e.point_radius_fixed)?void 0:a.value);return(0,u.tZ)("div",{className:"deckgl-tooltip"},(0,u.tZ)(l.Z,{label:(0,i.t)("Longitude and Latitude")+": ",value:`${o.object.position[0]}, ${o.object.position[1]}`}),o.object.cat_color&&(0,u.tZ)(l.Z,{label:(0,i.t)("Category")+": ",value:`${o.object.cat_color}`}),o.object.metric&&(0,u.tZ)(l.Z,{label:`${r}: `,value:`${o.object.metric}`}))}}function d(e,t,o,n,i){const s=e,l=t.data.features.map((e=>{let t=(o=s.point_unit,a=e.radius,("square_m"===o?Math.sqrt(a/Math.PI):"radius_m"===o?a:"radius_km"===o?1e3*a:"radius_miles"===o?a*c:"square_km"===o?1e3*Math.sqrt(a/Math.PI):"square_miles"===o?Math.sqrt(a/Math.PI)*c:null)||10);var o,a;if(s.multiplier&&(t*=s.multiplier),e.color)return{...e,radius:t};const n=s.color_picker||{r:0,g:0,b:0,a:1},i=[n.r,n.g,n.b,255*n.a];return{...e,radius:t,color:i}}));return new a.Z({id:`scatter-layer-${s.slice_id}`,data:l,fp64:!0,getFillColor:e=>e.color,getRadius:e=>e.radius,radiusMinPixels:Number(s.min_radius)||void 0,radiusMaxPixels:Number(s.max_radius)||void 0,stroked:!1,...(0,r.N)(s,n,g(s,null==i?void 0:i.verboseMap))})}const p=(0,s.B)(d,(function(e){return e.map((e=>e.position))}))},42932:(e,t,o)=>{o.r(t),o.d(t,{default:()=>N,getLayer:()=>E});var a=o(50308),n=o.n(a),i=o(67294),r=o(4942),s=o(41576),l=o(72958),c=o(24e3),u=o(44211),g=o(6948),d=o(39769),p=o(53982),h=o(5259),m=o(13717),f=o(79543);const v=[0,0,0,0],x=[0,255,0,255],_=["minColor","maxColor","colorRange","colorDomain"],y={cellSizePixels:{value:100,min:1},cellMarginPixels:{value:2,min:0,max:5},colorDomain:null,colorRange:f.K};class S extends h.Z{constructor(){super(...arguments),(0,r.Z)(this,"state",void 0)}static isSupported(e){return(0,u.ag)(e,[g.h.TEXTURE_FLOAT])}getShaders(){return{vs:"#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\n\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",fs:"#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[m.Z]}}initializeState(){const{gl:e}=this.context;this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel(e)})}shouldUpdateState(e){let{changeFlags:t}=e;return t.somethingChanged}updateState(e){super.updateState(e);const{oldProps:t,props:o,changeFlags:a}=e,n=this.getAttributeManager();o.numInstances!==t.numInstances?n.invalidateAll():t.cellSizePixels!==o.cellSizePixels&&n.invalidate("instancePositions"),this._updateUniforms(t,o,a)}draw(e){let{uniforms:t}=e;const{parameters:o,maxTexture:a}=this.props,n=this.props.minColor||v,i=this.props.maxColor||x,r=this.props.colorDomain||[1,0],{model:s}=this.state;s.setUniforms(t).setUniforms({minColor:n,maxColor:i,maxTexture:a,colorDomain:r}).draw({parameters:{depthTest:!1,depthMask:!1,...o}})}calculateInstancePositions(e,t){let{numInstances:o}=t;const{width:a,height:n}=this.context.viewport,{cellSizePixels:i}=this.props,r=Math.ceil(a/i),{value:s,size:l}=e;for(let e=0;e<o;e++){const t=e%r,o=Math.floor(e/r);s[e*l+0]=t*i/a*2-1,s[e*l+1]=1-o*i/n*2,s[e*l+2]=0}}_getModel(e){return new d.Z(e,{...this.getShaders(),id:this.props.id,geometry:new p.Z({drawMode:6,attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0])}}),isInstanced:!0})}_shouldUseMinMax(){const{minColor:e,maxColor:t,colorDomain:o,colorRange:a}=this.props;return e||t?(s.Z.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!o&&!a}_updateUniforms(e,t,o){const{model:a}=this.state;if(_.some((o=>e[o]!==t[o]))&&a.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),e.colorRange!==t.colorRange&&a.setUniforms({colorRange:(0,f.P)(t.colorRange)}),e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||o.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:o,cellMarginPixels:n}=this.props,i=o>n?n:0,r=new Float32Array([(o-i)/e*2,-(o-i)/t*2,1]);a.setUniforms({cellScale:r})}}}(0,r.Z)(S,"layerName","ScreenGridCellLayer"),(0,r.Z)(S,"defaultProps",y);var b=o(92026),C=o(21900);const P={...S.defaultProps,getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"},w="positions",L={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class Z extends b.Z{constructor(){super(...arguments),(0,r.Z)(this,"state",void 0)}initializeState(){const{gl:e}=this.context;if(!S.isSupported(e))return this.setState({supported:!1}),void s.Z.error("ScreenGridLayer: ".concat(this.id," is not supported on this browser"))();super.initializeAggregationLayer({dimensions:L,getCellSize:e=>e.cellSizePixels});const t={count:{size:1,operation:c.KM.SUM,needMax:!0,maxTexture:(0,C.hq)(e,{id:"".concat(this.id,"-max-texture")})}};this.setState({supported:!0,projectPoints:!0,weights:t,subLayerData:{attributes:{}},maxTexture:t.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[w]:{size:3,accessor:"getPosition",type:5130,fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState(e){let{changeFlags:t}=e;return this.state.supported&&t.somethingChanged}updateState(e){super.updateState(e)}renderLayers(){if(!this.state.supported)return[];const{maxTexture:e,numRow:t,numCol:o,weights:a}=this.state,{updateTriggers:n}=this.props,{aggregationBuffer:i}=a.count;return new(this.getSubLayerClass("cells",S))(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:n}),{data:{attributes:{instanceCounts:i}},maxTexture:e,numInstances:t*o})}finalizeState(e){super.finalizeState(e);const{aggregationBuffer:t,maxBuffer:o,maxTexture:a}=this.state;null==t||t.delete(),null==o||o.delete(),null==a||a.delete()}getPickingInfo(e){let{info:t}=e;const{index:o}=t;if(o>=0){const{gpuGridAggregator:e,gpuAggregation:a,weights:n}=this.state,i=a?e.getData("count"):n.count;t.object=l.Z.getAggregationData({pixelIndex:o,...i})}return t}updateResults(e){let{aggregationData:t,maxData:o}=e;const{count:a}=this.state.weights;a.aggregationData=t,a.aggregationBuffer.setData({data:t}),a.maxData=o,a.maxTexture.setImageData({data:o})}updateAggregationState(e){const t=e.props.cellSizePixels,o=e.oldProps.cellSizePixels!==t,{viewportChanged:a}=e.changeFlags;let n=e.props.gpuAggregation;this.state.gpuAggregation!==e.props.gpuAggregation&&n&&!l.Z.isSupported(this.context.gl)&&(s.Z.warn("GPU Grid Aggregation not supported, falling back to CPU")(),n=!1);const i=n!==this.state.gpuAggregation;this.setState({gpuAggregation:n});const r=this.isAttributeChanged(w),{dimensions:c}=this.state,{data:u,weights:g}=c,d=r||i||a||this.isAggregationDirty(e,{compareAll:n,dimension:u}),p=this.isAggregationDirty(e,{dimension:g});this.setState({aggregationDataDirty:d,aggregationWeightsDirty:p});const{viewport:h}=this.context;if(a||o){const{width:e,height:o}=h,a=Math.ceil(e/t),n=Math.ceil(o/t);this.allocateResources(n,a),this.setState({scaling:[e/2,-o/2,1],gridOffset:{xOffset:t,yOffset:t},width:e,height:o,numCol:a,numRow:n})}p&&this._updateAccessors(e),(d||p)&&this._resetResults()}_updateAccessors(e){const{getWeight:t,aggregation:o,data:a}=e.props,{count:n}=this.state.weights;n&&(n.getWeight=t,n.operation=c.KM[o]),this.setState({getValue:(0,c._D)(o,t,{data:a})})}_resetResults(){const{count:e}=this.state.weights;e&&(e.aggregationData=null)}}(0,r.Z)(Z,"layerName","ScreenGridLayer"),(0,r.Z)(Z,"defaultProps",P);var R=o(61988),A=o(63241),M=o(58371),D=o(51805),T=o(40461),k=o(34634),j=o(11965);function z(e){return(0,j.tZ)("div",{className:"deckgl-tooltip"},(0,j.tZ)(D.Z,{label:(0,R.t)("Longitude and Latitude")+": ",value:`${e.coordinate[0]}, ${e.coordinate[1]}`}),(0,j.tZ)(D.Z,{label:(0,R.t)("Weight")+": ",value:`${e.object.cellWeight}`}))}function E(e,t,o,a){const n=e,i=n.color_picker;let r=t.data.features.map((e=>({...e,color:[i.r,i.g,i.b,255*i.a]})));return n.js_data_mutator&&(r=(0,A.Z)(n.js_data_mutator)(r)),new Z({id:`screengrid-layer-${n.slice_id}`,data:r,cellSizePixels:n.grid_size,minColor:[i.r,i.g,i.b,0],maxColor:[i.r,i.g,i.b,255*i.a],outline:!1,getWeight:e=>e.weight||0,...(0,M.N)(n,a,z)})}const F=e=>{const t=(0,i.useRef)(),o=(0,i.useCallback)((()=>{const t=e.payload.data.features||[],{width:o,height:a,formData:n}=e;return n.autozoom?(0,T.Z)(e.viewport,{width:o,height:a,points:(i=t,i.map((e=>e.position)))}):e.viewport;var i}),[e]),[a,r]=(0,i.useState)(e.payload.form_data),[s,l]=(0,i.useState)(o());(0,i.useEffect)((()=>{e.payload.form_data!==a&&(l(o()),r(e.payload.form_data))}),[o,e.payload.form_data,a]);const c=(0,i.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),u=(0,i.useCallback)((()=>[E(e.formData,e.payload,n(),c)]),[e.formData,e.payload,c]),{formData:g,payload:d,setControlValue:p}=e;return(0,j.tZ)("div",null,(0,j.tZ)(k.F,{ref:t,viewport:s,layers:u(),setControlValue:p,mapStyle:g.mapbox_style,mapboxApiAccessToken:d.data.mapboxApiKey,width:e.width,height:e.height}))},N=(0,i.memo)(F)}}]);
//# sourceMappingURL=f1f4f99821e23046e7c8.chunk.js.map